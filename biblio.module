<?php
// $Id: biblio.module,v 1.36.2.184 2009/07/29 18:11:29 rjerome Exp $
/**
 *   biblio.module for Drupal
 *
 *   Copyright (C) 2006  Ron Jerome
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License along
 *   with this program; if not, write to the Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */
function biblio_autocomplete($field, $string='') {
    $matches = array();
    $result = db_query_range("SELECT $field FROM {biblio} WHERE LOWER($field) LIKE LOWER('%s%%') ORDER BY $field ASC", $string, 0, 10);
    while ($data = db_fetch_object($result)) {
      $matches[$data->$field] = check_plain($data->$field);
    }
    print drupal_to_js($matches);
    exit();
}
function biblio_help_page() {
  $base =  variable_get('biblio_base', 'biblio');

  $text .= "<h3>". t('General:') ."</h3>";
  $text .= "<p>". t('By default, the !url page will list all of the entries in the database sorted by Year in descending order. If you wish to sort by "Title" or "Type",  you may do so by clicking on the appropriate links at the top of the page.  To reverse the sort order, simply click the link a second time.', array('!url' => l('', $base))) ."</p>";
  $text .= "<h3>". t('Filtering Search Results:') ."</h3>";
  $text .= "<p>" . t('If you wish to filter the results, click on the "Filter" tab at the top of the page.  To add a filter, click the radio button to the left of the filter type you wish to apply, then select the filter criteria from the drop down list on the right, then click the filter button.') ."</p>";
  $text .= "<p>" . t('It is possible to create complex filters by returning to the <i>Filter</i> tab and adding additional filters.  Simply follow the steps outlined above and press the "Refine" button.') ."</p>";
  $text .= "<p>". t('All filters can be removed by clicking the <i>Clear All Filters</i> link at the top of the result page, or on the <i>Filter</i> tab they can be removed one at a time using the <i>Undo</i> button, or you can remove them all using the <i>Clear All</i> button.') ."</p>";
  $text .= "<p>". t('You may also construct URLs which filter.  For example, /biblio/year/2005 will show all of the entries for 2005.  /biblio/year/2005/author/smith will show all of entries from 2005 for smith.') ."</p>";
  $text .= "<h3>". t('Exporting Search Results:') ."</h3>";
  $text .= "<p>". t('Assuming this option has been enabled by the administrator, you can export search results directly into EndNote.  The link at the top of the result page will export all of the search results, and the links on individual entries will export the information related to that single entry.') ."</p>";
  $text .= "<p>". t('The information is exported in EndNote "Tagged" format similar to this...') .
              "<pre>". t('
              %0  Book
              %A  John Smith
              %D  1959
              %T  The Works of John Smith
              ...') .'
              </pre></p>';
  $text .= "<p>". t('Clicking on one of the export links should cause your browser to ask you whether you want to Open, or Save To Disk, the file endnote.enw.  If you choose to open it, Endnote should start and ask you which library you would like store the results in.  Alternatively, you can save the file to disk and manually import it into EndNote.') ."</p>";

  return  ($text);
}

/**
* Implementation of hook_help().
*
* Throughout Drupal, hook_help() is used to display help text at the top of
* pages. Some other parts of Drupal pages get explanatory text from these hooks
* as well. We use it here to provide a description of the module on the
* module administration page.
*/

function biblio_help($section) {
  switch ($section) {
    case 'admin/help#biblio':
      return biblio_help_page();

    case 'admin/modules#description':
      // This description is shown in the listing at admin/modules.
      return t('Manages a list of scholarly papers on your site');
    case 'node/add#biblio':
      // This description shows up when users click "create content."
      return t('This allows you to add a bibliographic entry to the database');
  }
}

function biblio_node_info() {
  return array('biblio' => array(
                    'name' => t('biblio'),
                    'module' => 'biblio',
                    'description' => t('Maintains list of bibliographies')));
}


/**
* Implementation of hook_access().
*
* Node modules may implement node_access() to determine the operations
* users may perform on nodes. This example uses a very common access pattern.
*/
function biblio_access($op, $node="") {
  global $user;

  switch ($op){
    case 'create':
      return user_access('create biblio');
    case 'import':
      return user_access('import from file');
    case 'export':
      return user_access('show export links');
    case 'download':
      if (user_access('show download links') || (user_access('show own download links') && ($user->uid == $node->uid)))
      {
        return TRUE;
      }
      break;
    case 'update':
    case 'delete':
      if (user_access('edit all biblio entries') || (user_access('edit own biblio entries') && ($user->uid == $node->uid)))
      {
        return TRUE;
      }
      break;
    case 'view':
      if (variable_get('biblio_view_only_own', 0) && $user->uid != $node->uid) {
        return false;
      }
      break;
    default:
  }
}

/**
* Implementation of hook_perm().
*
* Since we are limiting the ability to create new nodes to certain users,
* we need to define what those permissions are here. We also define a permission
* to allow users to edit the nodes they created.
*/
function biblio_perm() {
  return array('create biblio', 'edit all biblio entries', 'edit own biblio entries', 'import from file', 'show export links', 'show own download links', 'show download links', 'show filter tab', 'show sort links', 'input full text', 'view full text');
}
/**
* Implementation of hook_link().
*
* This is implemented so that an edit link is displayed for users who have
* the rights to edit a node.
*/
function biblio_link($type, $node = NULL, $teaser = FALSE) {
   $links = array();

   if ($type == 'node' && $node->type == 'biblio') {
     // Don't display a redundant edit link if they are node administrators.
     if (biblio_access('update', $node) && !user_access('administer nodes')) {
       $links['biblio_edit'] = array(
          'title' => t('edit this entry'),
          'href' => "node/$node->nid/edit",
        );
        return $links;
     }
  }
  return;
}
function theme_biblio_coin_button($element) {
  // Make sure not to overwrite classes.

  return '<a href="/biblio/regen_coins"><input type="button"  name="'. $element['#name'] .'" value="'. $element['#value'] .'"  /></a>';
}

/**
 * Implementation of hook_user().
 */
function biblio_user($type, &$edit, &$user, $category = NULL) {

  if ($type == 'view' && isset($user->biblio_show_profile)
                      && $user->biblio_show_profile == 1
                      && isset($user->biblio_show_profile_tab)
                      && $user->biblio_show_profile_tab == 0
                      && variable_get('biblio_show_profile', '0') == 1
                      && variable_get('biblio_show_profile_tab', '0') == 0) {

    $items['biblio'] = array('title' => '',
      'value' => _biblio_get_user_pubs($user,'profile') ,
      'class' => 'biblio',
    );

    return array(t('My publications') => $items);
  }

  if ($type == 'form' && $category == 'account' && (variable_get('biblio_show_profile', '0') || variable_get('biblio_my_pubs_menu', '0') )) {
    $form = array();
    _biblio_get_user_profile_form($form, $user);
    return $form;
  }

  if ($type == 'validate' && $category == 'account') {

    if( ( $edit['biblio_profile_uid'] == 'lastname' ||
          $edit['biblio_profile_uid'] ==  'uid_lastname' ) &&
          $edit['biblio_lastname'] == '' )
    {
        $message = t('You did not supply a value in the "My last name" field of the "My publications" section.');
        form_set_error('category', $message);
    }

  }

  if ($type == 'submit' && $category == 'account') {
    return ;
  }

  if ($type == 'delete' ) {
    return ;
  }

  return ;
}
/*
 * This functin is used by both the admin/settings/biblio page and user profile page
 *   - if $user is set, then it is being called from the user profile page
 */
function _biblio_get_user_profile_form(&$form, $user=false){
    $form['profile'] = array(
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => ($user) ? FALSE : TRUE,
      '#title' => ($user) ? t('My publications') : t('Profile pages'),

    );
    $form['profile']['biblio_show_profile'] = array(
      '#type' => 'checkbox',
      '#title' => ($user) ? t('Show my publications on my profile page') : t('Show publications on users profile pages'),
      '#return_value' => 1,
      $profile_value,
      '#description' => ($user) ? t('Selecting this will create a listing of your publications on your profile page') : t('This sets the site wide default, users may change this in their profile')
    );
    if($user){
        $form['profile']['biblio_show_profile']['#default_value'] = ( (isset($user->biblio_show_profile) ) ? $user->biblio_show_profile : variable_get('biblio_show_profile', '0')) ;
    }else{
        $form['profile']['biblio_show_profile']['#default_value'] = variable_get('biblio_show_profile', '0') ;
   }
    $form['profile']['biblio_show_profile_tab'] = array(
      '#type' => 'checkbox',
      '#title' => ($user) ? t('List my publications on a separate tab') : t('Show publications on a separate tab on users profile pages'),
      '#return_value' => 1,
      $profile_value,
      '#description' => ($user) ? t('Selecting this will create a listing of your publications on a separate tab on your profile page') : t('This sets the site wide default, users may change this in their profile')
    );
    if($user){
        $form['profile']['biblio_show_profile_tab']['#default_value'] = ( (isset($user->biblio_show_profile_tab) ) ? $user->biblio_show_profile_tab : variable_get('biblio_show_profile_tab', '0')) ;
    }else{
        $form['profile']['biblio_show_profile_tab']['#default_value'] = variable_get('biblio_show_profile_tab', '0') ;
   }
    $form['profile']['biblio_my_pubs_menu'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show "My publications" item in the navigation menu'),
      '#return_value' => 1,
      '#description' => ''
    );
    if($user){
        $form['profile']['biblio_my_pubs_menu']['#default_value'] = ( (isset($user->biblio_my_pubs_menu) ) ? $user->biblio_my_pubs_menu : 0) ;
    }else{
        $form['profile']['biblio_my_pubs_menu']['#default_value'] = variable_get('biblio_my_pubs_menu', '0') ;
   }
    if ($user) {
      $form['profile']['biblio_lastname'] = array(
        '#type' => 'textfield',
        '#title' => t('My last name'),
        '#default_value' => $user->biblio_lastname,
        '#description' => t('This may be ueed to determine which publications are mine')
      );
    }
    $form['profile']['biblio_profile_uid'] = array(
      '#type' => 'radios',
      '#title' => t('Select publications by'),
      '#default_value' => (isset($user->biblio_profile_uid) ) ? $user->biblio_profile_uid : variable_get('biblio_profile_uid', 'uid'),
      '#options' => array('uid' => t('User ID'), 'lastname' => ($user)?t('My last name'):t('Last name'), 'uid_lastname' => t('Both (Last name & User ID)')),
      '#description' => t('This defines the criteria used to select which publications will be listed on the users profile page'),
    );
}
/**
* Implementation of hook_settings().
*/
function biblio_settings() {

  include_once './includes/install.inc';
  module_load_install('biblio');
  if ($versions = drupal_get_schema_versions('biblio')){
    $installed_version = drupal_get_installed_schema_version('biblio');
    if ($installed_version < max($versions)){
      drupal_set_message(t("There are updates available for the Biblio module, please run the update.php script"), 'error');      }
  }

  $version = '$Revision: 1.36.2.184 $ $Date: 2009/07/29 18:11:29 $';
  $version = str_replace('$', '', $version);
  $form['biblio_rev'] = array(
     '#value' => $version,
  );
  $form['biblio_base'] = array(
    '#type' => 'textfield',
    '#title' => t('Base URL'),
    '#size' => 20,
    '#default_value' => variable_get('biblio_base', 'biblio'),
    '#description' =>  t('This sets the base URL used to access the biblio module (e.g. /biblio ).'),
  );
  $form['biblio_rowsperpage'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of results per page'),
    '#default_value' => variable_get('biblio_rowsperpage', 25),
    '#size' => 6,
    '#maxlength' => 6,
    '#description' => t('This sets the number of results that will be displayed per page.'),
  );
  $form['biblio_view_only_own'] = array(
    '#type' => 'checkbox',
    '#title' => t('Restrict users such that they can only view their own biblio entries'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_view_only_own', 0),
    '#description' => t('This option restricts the users capability to view biblio entries.  They will only be able to see the entries which they have created and own.') );
  $form['biblio_input_full_text'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow users to input full text of publications'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_input_full_text', 1),
    '#description' => t('Un-checking this will remove the "Full Text" area from the input form') );

  $form['block'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Block settings'),
    '#description' => '',
  );
  $form['block']['biblio_block_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title for the "New Publications" block'),
    '#default_value' => variable_get('biblio_block_title', 'New Publications'),
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => '',
  );
  $form['block']['biblio_rowsperblock'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of results in the "New Publications" block'),
    '#default_value' => variable_get('biblio_rowsperblock', 4),
    '#size' => 2,
    '#maxlength' => 2,
    '#description' => t('This sets the number of results that will be displayed in the "New Publications" block.'),
  );
  $form['block']['biblio_block_order'] = array(
    '#type' => 'radios',
    '#title' => t('Order by'),
    '#default_value' => variable_get('biblio_block_order', 'n.created'),
    '#options' => array('n.created' => t('Date Created'), 'b.biblio_year' => t('Year Published')),
  );
  $result = db_query("SELECT b.name, b.title FROM {biblio_fields} b
						ORDER by b.title ASC ");
  $choice = new stdClass();
  $choice->option = array('nid' =>   t('Node ID'));
  $options[0] = $choice;
  while ($row = db_fetch_array($result)) {
		$fields[$row['name']] = $row;
       $choice = new stdClass();
        $choice->option = array($row['name'] =>  $row['title']);
        $options[] = $choice;
	  }

  $form['citekey'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Citekey'),
    '#description' => t('You can alter citekey related settings here.'),
  );
  $form['citekey']['biblio_auto_citekey'] = array(
    '#type' => 'checkbox',
    '#title' => t('Auto generate citekeys if not given'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_auto_citekey', 1),
    '#description' => t('This option will cause "citekey" entries to be automatically generated if a value is not provided.')
    );
  $form['citekey']['biblio_citekey_prefix'] = array(
    '#type' => 'textfield',
    '#title' => t('Citekey prefix'),
    '#default_value' => variable_get('biblio_citekey_prefix', ''),
    '#size' => 10,
    '#maxlength' => 10,
    '#description' => t('This text will be combined with the field choosen below to form the auto generated citekey.'),
  );
  $form['citekey']['biblio_citekey_field1'] = array(
    '#type' => 'select',
    '#title' => t('Primary Citekey  field'),
    '#default_value' => variable_get('biblio_citekey_field1', 'nid'),
    '#options' => $options,
    '#description' => t('Select the field to be used when generating citekeys.'),
    );
  $form['citekey']['biblio_citekey_field2'] = array(
    '#type' => 'select',
    '#title' => t('Secondary Citekey field'),
    '#default_value' => variable_get('biblio_citekey_field2', 'nid'),
    '#options' => $options,
    '#description' => t('If the field above has no value this field will be used.'),
    );

  $form['footnotes'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Footnotes'),
    '#description' => t('You can integrate with the !url module here.', array('!url' => l('footnotes', url("http://www.drupal.org/project/footnotes", NULL, NULL, TRUE)))),
  );
  if (!module_exists('footnotes')) {
    $additional_text = '<div class="admin-dependencies">'. t('Depends on') .': '. t('Footnotes') .' (<span class="admin-disabled">'. t('disabled') .'</span>)</div>';
    $disabled = TRUE;
    variable_set('biblio_footnotes_integration', 0);
  }
  else{
    $additional_text = '<div class="admin-dependencies">'. t('Depends on') .': '. t('Footnotes') .' (<span class="admin-enabled">'. t('enabled') .'</span>)</div>';
    $disabled = FALSE;

  }
  $form['footnotes']['biblio_footnotes_integration'] = array(
    '#type' => 'checkbox',
    '#title' => t('Integration with the footnotes module') . $additional_text,
    '#disabled' => $disabled,
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_footnotes_integration', 0),
    '#description' => t('This will convert &lt;bib&gt; tags into &lt;fn&gt; tags.  This will cause intermingled &lt;bib&gt; and &lt;fn&gt; tags to be sequentially numbered.  For this to work, you must put the &lt;bib&gt; filter ahead of the &lt;fn&gt; filter in the filter chain.  If this option is not set, &lt;bib&gt; and &lt;fn&gt; tags will be handled separately.'),
  );
  $form['keywords'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Keywords'),
    '#description' => '',
  );
  $form['keywords']['biblio_keyword_sep'] = array(
    '#type' => 'textfield',
    '#title' => t('Keyword separator'),
    '#size' => 2,
    '#default_value' => variable_get('biblio_keyword_sep', ','),
    '#description' =>  t('Enter the character which will be used to separate multiple keywords in the keyword field'),
  );
	$form['links'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Links'),

  );
  $form['links']['biblio_links_target_new_window'] = array(
    '#type' => 'checkbox',
    '#title' => t('Links open in new browser'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_links_target_new_window', 0),
    '#description' => t('This causes related URLs to open in a new browser window') );
/*  $form['links']['biblio_inlinemode_in_links'] = array(
    '#type' => 'checkbox',
    '#title' => t('Carry "inline" mode through to all links'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_inlinemode_in_links', 0),
    '#description' => t('This causes the "inline" mode to be applied to all links such as titles, authors and keywords') );
*/
  $form['links']['biblio_link_title_url'] = array(
    '#type' => 'checkbox',
    '#title' => t('Hyperlink titles using supplied URL if available'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_link_title_url', 0),
    '#description' => t('Selecting this links the titles to the supplied URL (if available) rather than the "node" view.') );
  $form['openurl'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('OpenURL'),
    '#description' => t('You can set an <a href="http://en.wikipedia.org/wiki/OpenURL">openurl</a> link here'),
  );
  $form['openurl']['biblio_baseopenurl'] = array(
    '#type' => 'textfield',
    '#title' => t('OpenURL Base URL'),
    '#size' => 95,
    '#default_value' => variable_get('biblio_baseopenurl', ''),
    '#description' =>  t('This sets your institution\'s base <a href="http://en.wikipedia.org/wiki/OpenURL">OpenURL</a> gateway, which is used to generate OpenURL links. To implement a "Universal" OpenURL system, try using OCLC\'s <a href="http://www.oclc.org/productworks/urlresolver.htm">OpenURL Resolver Registry</a> gateway: <a href="http://worldcatlibraries.org/registry/gateway">http://worldcatlibraries.org/registry/gateway</a>'),
  );
  $form['openurl']['biblio_openurlimage'] = array(
    '#type' => 'textfield',
    '#title' => t('OpenURL Image'),
    '#size' => 95,
    '#default_value' => variable_get('biblio_openurlimage', ''),
    '#description' =>  t('Enter a path to your image here, this image will be used as button which when clicked will find the entry via the OpenURL link'),
  );

  _biblio_get_user_profile_form($form);

  $form['sort'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Sorting'),
    '#description' => t('You can set the default sorting and ordering for the /biblio page here.'),
  );
  $form['sort']['biblio_sort'] = array(
    '#type' => 'radios',
    '#title' => t('Sort by'),
    '#default_value' => variable_get('biblio_sort', 'year'),
    '#options' => array('author' => t('Author'), 'keyword' => t('Keyword'), 'title' => t('Title'), 'type' => t('Type'), 'year' => t('Year')),
  );
  $form['sort']['biblio_sort_tabs'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Show sort links'),
    '#default_value' => variable_get('biblio_sort_tabs', array('author', 'title', 'type', 'year')),
    '#options' => array('author' => t('Author'), 'keyword' => t('Keyword'), 'title' => t('Title'), 'type' => t('Type'), 'year' => t('Year')),
    '#description' => t('You turn the sorting links at the top of the /biblio page here.'),
  );
  $form['sort']['biblio_order'] = array(
    '#type' => 'radios',
    '#title' => t('Order'),
    '#default_value' => variable_get('biblio_order', 'DESC'),
    '#options' => array('DESC' => t('Descending'), 'ASC' => t('Ascending')),
  );
  $form['style'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Styling'),
    '#description' => t('You can set the default style for the /biblio page here.'),
  );
  $form['style']['biblio_normalize'] = array(
    '#type' => 'checkbox',
    '#title' => t('Normalize author names when displaying biblio records'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_normalize', 0),
    '#description' => t('Tries (doesn\'t always work) to reformat author names so that they are displayed in the format "Lastname, Initials" e.g. Smith, J.S. (Note: This setting does not modify the entry in the database, it only reformats it\'s presentation. This option can be turned off at any time to diplay the oringal format.)'), );
  $form['style']['biblio_node_layout'] = array(
    '#type' => 'radios',
    '#title' => t('Node Layout'),
    '#default_value' => variable_get('biblio_node_layout', 'orig'),
    '#options' => array('orig' => t('Original'), 'ft' => t('Only Fulltext if available'), 'tabular' => t('Tabular')),
    '#description' => t('This alters the layout of the "node" (full) view.'),
  );
  $form['style']['biblio_annotations'] = array(
    '#type' => 'select',
    '#title' => t('Annotations'),
    '#default_value' => variable_get('biblio_annotations', 'none'),
    '#options' => array('none' => t('none'), 'biblio_notes' => t('notes'), 'biblio_custom1' => t('custom1'), 'biblio_custom2' => t('custom2'), 'biblio_custom3' => t('custom3'), 'biblio_custom4' => t('custom4'), 'biblio_custom5' => t('custom5'), 'biblio_custom6' => t('custom6'), 'biblio_custom7' => t('custom7')),
    '#description' => t('Select a field from which an annotation will be displayed below biblo entry in "short" listings'),
    '#multiple' => FALSE,
    '#size' =>  0
  );
  $form['style']['biblio_style'] = array(
    '#type' => 'radios',
    '#title' => t('Style'),
    '#default_value' => variable_get('biblio_style', 'classic'),
    '#options' => _biblio_get_styles(),
    '#description' => t('This alters the layout of the "list" (short) view.'),
  );
  $form['syndication'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Syndication'),
    '#description' => t('You can set the RSS defaults here.'),
  );
  $form['syndication']['biblio_rss'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow RSS feeds of new biblio entries'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_rss', 0),
    '#description' => t('This will create an rss feed of the 10 most recent biblio entries. It will be available at /biblio/rss.xml'),
  );
  $form['syndication']['biblio_rss_number_of_entries'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of items in the RSS feed.'),
    '#default_value' => variable_get('biblio_rss_number_of_entries', 10),
    '#size' => 6,
    '#maxlength' => 6,
    '#description' => t('Limits the number of items in the /biblio/rss.xml feed to this number.'),
  );

  $form['taxo'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Taxonomy'),
    '#description' => t('You can set the Taxonomy defaults here.'),
  );
  $form['taxo']['biblio_keyword_freetagging'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use keywords from biblio entries as taxonomy "free tags"'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_keyword_freetagging', 0),
    '#description' => t('This option allows user to add keywords (free tags) to describe their documents. These keywords will be registered as taxonomy.'),
   );
  $vocabularies = module_invoke('taxonomy', 'get_vocabularies');
   // ... and print a form to select the terms in each of them
  $choice = new stdClass();
  $choice->option = array(0 =>  '<'. t('none') .'>');
  $options[0] = $choice;
  if (count($vocabularies)) {
    foreach ($vocabularies as $voc) {
        $choice = new stdClass();
        $choice->option = array($voc->vid =>  $voc->name);
        $options[] = $choice;
    }

    $form['taxo']['biblio_freetagging_vocab'] = array(
    '#type' => 'select',
    '#title' => t('Vocabulary'),
    '#default_value' => variable_get('biblio_freetagging_vocab', 0),
    '#options' => $options,
    '#description' => t('Select vocabulary (category) to use for free tags.'),
    '#multiple' => FALSE,
    '#disabled' => (!variable_get('biblio_keyword_freetagging', 0)),
    '#size' => $multiple ? min(9, count($options)) : 0,
    '#weight' => 15,
    );

  }

  return system_settings_form($form);
}

/*  This function parses the module directory for 'style' files, loads them and
 *  calls the info fuction to get some basic information like the short and long
 *  names of the style
*/
function _biblio_get_styles() {
  $styles = array();
  $dir    = drupal_get_path('module', 'biblio');
  $files  = array();
  if ($dh = opendir($dir)) {
    while (($files[] = readdir($dh)) !== false) {
    }
    closedir($dh);
    foreach ($files as $file) {
      if (strstr ( $file, 'biblio_style_')) { //find the style files
        include_once $dir ."/". $file;
        if (function_exists(basename($file, ".inc") .'_info')) {
          $styles = array_merge($styles, call_user_func(basename($file, ".inc") .'_info')); //build and array of the short and long names
        }
      }
    }
  }
  return ($styles);
}
/**
* Implementation of hook_menu().
*
* Here we define some built in links for the biblio module, links exposed are:
*   /node/add/biblio      => to add a single entry
*   /biblio               => lists all entries in the biblio database
*   /biblio/list          => default local task for /biblio
*   /biblio/filter        => local task which allows users to add filters to their query
*   /biblio/filter/clear  => used internally to remove all filters
*   /biblio/help          => displays a help page
*   /biblio/export/endnote => used to export information in Endnote Tagged format
*   /biblio/import/form   => presents a form to allow the user to upload a file to import
*
*
*/
function biblio_menu($may_cache) {

  global $user;
  $items = array();

  if ($may_cache) {
    $items[] = array(
        'path' => 'node/add/biblio',
        'title' => t('Bibliography'),
        'access' => user_access('create biblio')
    );
    // The next two "LOCAL TASKS" are for the admin/settings/biblio page
    $items[] = array(
        'path' => 'admin/settings/biblio',
        'title' => t('Biblio settings'),
        'description' => t('Configure default behavior of the biblio module.'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_settings')
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/basic',
        'title' => t('Preferences'),
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => -10
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/import',
        'title' => t('File Import'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_form_import'),
        'type' => MENU_LOCAL_TASK, 'weight' => -7
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types',
        'title' => t('Type Customization'),
        'callback' => 'biblio_form_types',
        'type' => MENU_LOCAL_TASK,
        'weight' => -8
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/defaults',
        'title' => t('Field Defaults'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_form_types_edit'),
        'type' => MENU_LOCAL_TASK ,
        'weight' => -9
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/add',
        'title' => '',
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_form_types_add'),
        'type' => MENU_CALLBACK
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/edit',
        'title' => '',
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_form_types_edit'),
        'type' => MENU_CALLBACK
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/delete',
        'title' => '',
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_form_types_delete'),
        'type' => MENU_CALLBACK
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/new',
        'title' => t('Add New Type'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_form_types_add'),
        'type' => MENU_LOCAL_TASK,
        'weight' => -9
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/reset',
        'title' => t('Reset all types to defaults'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('biblio_types_reset'),
        'type' => MENU_LOCAL_TASK
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/hide',
        'title' => '',
        'callback' => 'biblio_types_hide',
        'type' => MENU_CALLBACK
    );

    $items[] = array(
        'path' => 'admin/settings/biblio/types/show',
        'title' => '',
        'callback' => 'biblio_types_show',
        'type' => MENU_CALLBACK
    );

    $items[] = array(
        'path' => 'biblio/autocomplete',
        'title' => t('Autocomplete'),
        'callback' => 'biblio_autocomplete',
        'access' => user_access('access content'),
        'type' => MENU_CALLBACK
    );
  } // end if ($may_cache)

  $base =  variable_get('biblio_base', 'biblio');

  $items[] = array(
      'path' => $base, 'title' => '',
      'callback' => 'biblio_db_search',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK
  );

  if ($user->uid  && variable_get('biblio_my_pubs_menu', '0') && ( (isset($user->biblio_my_pubs_menu) ) ? $user->biblio_my_pubs_menu : 0))  {
    $items[] = array(
      'path' => "$base/user",
      'title' => t('My publications'),
      'callback' => '_biblio_get_user_pubs',
      'callback arguments' => array($user) ,
      'type' => MENU_DYNAMIC_ITEM
    );
  }

  if (arg(0) == 'user' && is_numeric(arg(1))) {
     $account = user_load(array('uid' => arg(1)));
     if (variable_get('biblio_show_profile', '0') == 1
         && variable_get('biblio_show_profile_tab', '0') == 1
         || $account->biblio_show_profile_tab == 1) {

     $items[] = array(
        'path' => 'user/'. arg(1) .'/biblio',
        'title' => t('Publications'),
        'callback' => '_biblio_get_user_pubs',
        'callback arguments' => array($account, 'profile') ,
        'access' => user_access('access content'),
        'type' => MENU_IS_LOCAL_TASK);
    }
  }

  $items[] = array(
    'path' => "$base/list",
    'title' => t('List'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );

  $items[] = array(
    'path' => "$base/filter",
    'title' => t('Filter'),
    'callback' => 'drupal_get_form',
    'callback arguments' => array('biblio_form_filter'),
    'access' => user_access('show filter tab'),
    'type' => MENU_LOCAL_TASK, 'weight' => -9
  );

  $items[] = array(
    'path' =>  "$base/filter/clear",
    'title' => '',
    'callback' => 'biblio_filter_clear',
    'access' => user_access('access content'),
    'type' => MENU_CALLBACK
  );

  $items[] = array(
    'path' => "$base/help",
    'title' => t('Help'),
    'callback' => 'biblio_help_page',
    'access' => user_access('access content'),
    'type' => MENU_CALLBACK
  );

  $items[] = array(
    'path' => "$base/import/form",
    'title' => '',
    'callback' => 'drupal_get_form',
    'callback arguments' => array('biblio_form_import'),
    'access' => user_access('import from file'),
    'type' => MENU_CALLBACK
  );

  $items[] = array(
    'path' => "$base/export",
    'title' => '',
    'callback' => '_biblio_export',
    'access' => user_access('show export links'),
    'type' => MENU_CALLBACK
  );

  $items[] = array(
    'path' => "$base/type/add",
    'title' => '',
    'callback' => 'biblio_type_add',
    'type' => MENU_CALLBACK
  );

  $items[] = array(
    'path' => "$base/type/remove",
    'title' => '',
    'callback' => 'biblio_type_remove',
    'type' => MENU_CALLBACK
  );

  $items[] = array(
    'path' => "$base/citekey",
    'title' => '',
    'callback' => 'biblio_citekey_view',
    'type' => MENU_CALLBACK
  );
  if (arg(1) == 'viewinline' && is_numeric(arg(2))) {
    $node = node_load(arg(2));
    if ($node->nid) {
      $items[] = array(
        'path' => "$base/viewinline/". arg(2),
        'title' => '',
        'callback' => 'biblio_view_inline',
        'callback arguments' => array($node),
        'access' => node_access('view', $node),
        'type' => MENU_CALLBACK
      );
    }
  }

  if (variable_get('biblio_rss', 0)) {
    $items[] = array(
      'path' => "$base/rss.xml",
      'title' => t('RSS feed'),
      'callback' => 'biblio_feed',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK
    );
  }
  return $items;
}
function biblio_form_types_add() {
    $form['type_name'] = array('#type' => 'textfield',
                          '#title' => t('Type Name'),
                          '#size' => 20,
                          '#weight' => 1,
                          '#required' => true,
                          '#maxlength' => 64);
    $form['type_description'] = array('#type' => 'textfield',
                                 '#title' => t('Description'),
                                 '#size' => 60,
                                 '#weight' => 2,
                                 '#maxlength' => 255);
    $form['type_button'] = array('#type' => 'submit',
                    '#value' => t('Create New Type'),
                    '#weight' => 3);
    return $form;
}

function biblio_form_types_add_submit($form_id, $edit) {

   $tid =  variable_get('biblio_max_user_tid', '999') + 1;
   $query = "INSERT INTO {biblio_types} (`name`,`description`,`tid`) VALUES ('%s', '%s','%d')";
   db_query($query, $edit['type_name'], $edit['type_description'], $tid);
   variable_set('biblio_max_user_tid', $tid);
   drupal_goto('admin/settings/biblio/types');

}
function biblio_types_hide() {
 $args = func_get_args();
 if ($args[0] > 0 && is_numeric($args[0]) ) {
    $result = db_query('UPDATE {biblio_types} SET visible = 0 WHERE tid = %d ', $args[0]);
 }
 drupal_goto('admin/settings/biblio/types');
}
function biblio_types_show() {
 $args = func_get_args();
 if ($args[0] > 0 && is_numeric($args[0]) ) {
    $result = db_query('UPDATE {biblio_types} SET visible = 1 WHERE tid = %d ', $args[0]);
 }
 drupal_goto('admin/settings/biblio/types');
}
function biblio_form_types_delete() {
 $args = func_get_args();
 if ($args[0] > 0 && is_numeric($args[0]) ) {
    $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid = %d ', $args[0]);
    $row = db_fetch_array($result);
    $result = db_query('SELECT b.* FROM {biblio} as b WHERE b.biblio_type = %d', $row['tid']);
    if ($num_rows = db_num_rows($result)) {
      $existing_msg = t('There are @count biblio entries of this type, you should change the type of these entries before proceeding otherwise they will be deleted', array('@count' => $num_rows));
    }

    $form['tid'] = array('#type' => 'value', '#value' => $row['tid']);
    $output = confirm_form( $form,
           t('Are you sure you want to delete the custom biblio type:  %title ? ', array('%title' => $row['name'])) . $existing_msg,
           $_GET['destination'] ? $_GET['destination'] : 'admin/settings/biblio/types', t('This action cannot be undone.'),
           t('Delete'), t('Cancel')  );

    return $output;
  }
  else{
    drupal_goto('admin/settings/biblio/types');
  }
}
function biblio_form_types_delete_submit($form_id, $edit) {

  if ($form_id = "biblio_form_types_delete" ) {
    db_query('DELETE FROM {biblio_types} WHERE tid = %d', $edit['tid']);
  }
    drupal_goto('admin/settings/biblio/types');
}
function biblio_form_types() {

  $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid > 0');
  //$rows[] = array('',t('Fields Common To All Types'),l('edit', 'admin/settings/biblio/types/edit'),'');

  while ($row = db_fetch_object($result)) {
    if ($row->tid < 999) {
      $rows[] = array($row->tid, $row->name, ($row->visible)?l(t('edit'), 'admin/settings/biblio/types/edit/'. $row->tid):'', ($row->visible)?l(t('hide'), 'admin/settings/biblio/types/hide/'. $row->tid):l(t('show'), 'admin/settings/biblio/types/show/'. $row->tid));
    }
    else{
      $rows[] = array($row->tid, $row->name, l(t('edit'), 'admin/settings/biblio/types/edit/'. $row->tid), l(t('delete'), 'admin/settings/biblio/types/delete/'. $row->tid));
    }
  }
  $header =array(t('Type Id'), t('Type Name'), array('data' => t('Operations'), 'colspan' => '2'));
  $output  = theme('table', $header, $rows);
  $output .= '<p>[ '. l(t('Add New Type'), 'admin/settings/biblio/types/add') .' ]';
  $output .= ' [ '. l(t('Reset all types to defaults'), 'admin/settings/biblio/types/reset') .' ]';
  return $output;

}
function biblio_types_reset() {

    $form['reset'] = array('#type' => 'value', '#value' => 'reset');

    $output = confirm_form( $form,
           t('Are you sure you want to reset ALL the field definitions to the defaults? '),
           $_GET['destination'] ? $_GET['destination'] : 'admin/settings/biblio/types',
           t('This action will reset any and all field customizations to the defaults, and cannot be undone!'),
           t('Reset'), t('Cancel')  );

    return $output;

}
function biblio_types_reset_submit($form_id, $edit) {
  require_once( drupal_get_path('module', 'biblio') ."/biblio.install");
  biblio_reset_types();
  drupal_goto("admin/settings/biblio/types");

}
function biblio_show_node($node, $base, $teaser = false) {
  $tid=$node->biblio_type;
  $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
  while ($row = db_fetch_array($result)) {
    if ($row['common']) {
      $fields[$row['fid']] = $row;
    }
  }
 // $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid = %d', $tid);
 // $row = db_fetch_array($result);
 // $type_name=$row['name'];
  $result = db_query('SELECT d.*, f.name, f.type FROM {biblio_type_details} as d INNER JOIN {biblio_fields} as f on d.fid=f.fid where d.tid=%d  ORDER BY d.weight ASC', $tid);
  while ($row = db_fetch_array($result)) {
    $fields[$row['fid']] = (isset($fields[$row['fid']])) ? array_merge($fields[$row['fid']], $row) : $row;
  }
  uasort($fields, "_biblio_form_sort"); // resort the fields since the weight may have changed
  if ($teaser) {
//    $rows[] =array(array('data' =>  '<hr>', 'colspan'=>'3'));
//    $rows[] =array(array('data' =>  '<span class="biblio-row-title">'.t('Title').'</span>','align'=>'right'),
//                   array('data' => '&nbsp;&nbsp;'),
//                   array('data' => l($node->title, 'node/'.$node->nid)));
   unset($fields[21]);
  }
  $rows[] = array(array('data' =>  '<span class="biblio-row-title">'. t('Publication Type') .'</span>', 'align' => 'right'),
                 array('data' => '&nbsp;&nbsp;'),
                 array('data' => theme('biblio_type_link', $node->biblio_type_name, $tid, $base)));

  if ($node->biblio_authors) {
    if (variable_get('biblio_normalize', 0)) {
      $node->biblio_authors = _biblio_parse_authors($node->biblio_authors);
    }
    $node->biblio_authors = _biblio_author_links($node->biblio_authors, $base);
  }
  if ($node->biblio_keywords) {
   $node->biblio_keywords = _biblio_keyword_links($node->biblio_keywords, $base);
  }
  if ($node->biblio_publisher) {
   $node->biblio_publisher = theme('biblio_publisher_link',$node->biblio_publisher, $base);
  }
  if ($node->biblio_url) {
   $node->biblio_url = l($node->biblio_url, $node->biblio_url);
  }

  foreach ($fields as $key => $row) {
    if (!empty($node->$row['name']) && ($row['name'] != 'biblio_coins') ) {
      switch ($row['name']) {
      case 'biblio_authors':
      case 'biblio_keywords':
      case 'biblio_url':
      case 'biblio_publisher':
        // check_plain is not need on these since they have gone through
        // the l() function which does a check_plain
        $data = $node->$row['name'];
        break;
      default:
        if ( $row['type'] == 'textarea' ) {
          $data = check_markup($node->$row['name'], $node->format, FALSE);
        }else{
          $data = check_plain($node->$row['name']);
        }
      }
      $rows[] = array(array('data' => '<span class="biblio-row-title">'. $row['title'] .'</span>', 'align' => 'right', 'valign' => 'top', 'width' => '20%'),
                      array('data' => '&nbsp;&nbsp;'),
                      array('data' => $data));
    }
  }
  if ( strlen(trim($node->body)) && $teaser == false && user_access('view full text') ) {
     $rows[] = array(array('data' => '<span class="biblio-row-title">'.t('Full Text').'</span>','align'=>'right','valign'=>'center','width'=>'20%'),
                      array('data' => '&nbsp;&nbsp;'),
                      array('data' => check_markup($node->body, $node->format, FALSE))
                            );
  }
  if ( biblio_access('export',$node) && $teaser == false ) {
    $rows[] = array(array('data' => '<span class="biblio-row-title">'.t('Export').'</span>','align'=>'right','valign'=>'center','width'=>'20%'),
                      array('data' => '&nbsp;&nbsp;'),
                      array('data' => theme('biblio_tagged_link',$base, $node ).' '.
                                      l(t("XML"),"$base/export/xml/$node->nid").' '.
                                      theme('biblio_bibtex_link',$base, $node )
                            ));

  }

  $output = '<div id="biblio-node">';
  $output .= $node->biblio_coins;
  $output .= theme('table',$header,$rows);
  $output .= '</div>';

  return $output;
}

function theme_biblio_tagged_link($base, $node = NULL)
{
   $output = '<span hovertip="taggedExp">';
   if (module_exists('hovertip')) {
     $output .= '<div id="taggedExp" class="hovertip"><h1>EndNote Tagged</h1>'.nl2br(_endnote_tagged_export($node)) .'</div>';
   }
   $output .= l(t("Tagged"),"$base/export/tagged/$node->nid") .'</span>';
   return $output;
}

function theme_biblio_bibtex_link($base, $node = NULL)
{
   $output = '<span hovertip="bibtexExp">';
   if (module_exists('hovertip')) {
     $output .= '<div id="bibtexExp" class="hovertip"><h1>BibTex</h1>'.nl2br(_bibtex_export($node)) .'</div>';
   }
   $output .= l(t("BibTex"),"$base/export/bib/$node->nid") .'</span>';
   return $output;
}

function theme_biblio_publisher_link($publisher, $base='biblio'){
  $query = NULL;
  foreach ($_GET as $key => $value ){
    if ($key != 'q' )
    {
      $query .= $key.'='.$value; // $query will contain any addional URL query elements not related to this module
    }
  }
  if (!empty($query)) $query = '&'.$query;
  return  l(trim($publisher), "$base/publisher/" . trim($publisher), NULL, $query);
}

function theme_biblio_type_link($type_name, $tid, $base='biblio'){
  $query = NULL;
  foreach ($_GET as $key => $value ){
    if ($key != 'q' )
    {
      $query .= $key.'='.$value; // $query will contain any addional URL query elements not related to this module
    }
  }
  if (!empty($query)) $query = '&'.$query;
  return  l(trim($type_name), "$base/type/" . trim($tid), NULL, $query);
}

function biblio_form_types_edit() {
  if ($arg_list = func_get_args()) {// show an existing type
    $tid = $arg_list[0];
  }
  // first get all of the field info
  $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
  while ($row = db_fetch_array($result)) {
    if ($tid) {
      if ($row['common']) {
        $fields[$row['fid']] = $row;
      }else{
         $other_fields[$row['fid']] = $row;
      }
    }else{
      $fields[$row['fid']] = $row;
    }
  }
  $form['configured_flds']= array('#tree'=>1);
  $form['cust'] = array('#tree'=>1);
  if ($tid) {// show an existing type

    $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid = %d',$tid);
    $row = db_fetch_array($result);
    $form['type_name'] =array('#type'=>'value','#title'=>'tid','#value'=>$row['name']);

   // now get any type specific customizations
    $result = db_query('SELECT d.*, f.name FROM {biblio_type_details} as d INNER JOIN {biblio_fields} as f on d.fid=f.fid where d.tid=%d  ORDER BY d.weight ASC', $tid);
    while ($row = db_fetch_array($result)) {
      $type_fields[$row['fid']] = $row;
      $form['cust'][$row['fid']] =array('#type'=>'value','#value'=>$row['fid']);
      unset($other_fields[$row['fid']]);
    }
    if (count($type_fields)) {
    // now merge the customizations with the main field array
    foreach($type_fields as $key=>$value) {
        $fields[$key] = (isset($fields[$key])) ? array_merge($fields[$key],$value) : $value;
    }
    }

    $form['tid'] =array('#type'=>'value','#value'=>$tid);
  }

  uasort($fields, "_biblio_form_sort"); // resort the fields since the weight may have changed

  $vis_comm = $tid?'visible':'common';
  if (!$tid) $options["$vis_comm"] = '';
  $options['required'] = '';
  if (!$tid) $options['autocomplete'] = '';

  foreach($fields as $key=>$fld) {
    if ($fld['common']) $def_values[$fld['name']][] = 'common';
    if ($fld['required']) $def_values[$fld['name']][] = 'required';
    if ($fld['autocomplete']) $def_values[$fld['name']][] = 'autocomplete';

    $form['configured_flds'][$key]['name'] = array('#type'=>'markup', '#value'=>$fld['name'],'#weight'=>$fld['weight']);
    $form['configured_flds'][$key]['title'] = array('#type'=>'textfield','#default_value' => $fld['title'],'#size'=>15,'#weight'=>$fld['weight']);
    $form['configured_flds'][$key]['weight'] = array('#type'=>'textfield','#default_value' => $fld['weight'],'#size'=>2,'#weight'=>$fld['weight']);
    $form['configured_flds'][$key]['hint'] = array('#type'=>'textfield','#default_value' => $fld['hint'],'#size'=>10, '#maxlength'  => 255, '#weight'=>$fld['weight']);
    //if (!$tid) {
    //  $form['configured_flds'][$key]['hint']['#type']= 'markup';
    //  $form['configured_flds'][$key]['title']['#type']= 'markup';
    //}
    $form['configured_flds'][$key]['checkboxes'] = array('#type'=>'checkboxes','#options'=>$options,'#default_value' =>$def_values[$fld['name']],'#weight'=>$fld['weight']);
  }

  if ($tid) {
    foreach($other_fields as $key=>$fld) {
      $form['avail_flds'][$key]['name'] = array('#type'=>'markup', '#value'=>$fld['name'],'#weight'=>$fld['weight']);
      $form['avail_flds'][$key]['title'] = array('#type'=>'markup','#value' => $fld['title'],'#weight'=>$fld['weight']);
      $form['avail_flds'][$key]['size'] = array('#type'=>'markup','#value' => $fld['maxsize'],'#weight'=>$fld['weight']);
    }
  }
  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));

  return $form;
}


function theme_biblio_form_types_edit($form) {
  $base =  variable_get('biblio_base', 'biblio');

  $tid = (!empty($form['tid']['#value'])) ? $form['tid']['#value'] : FALSE;

  drupal_set_title($form['type_name']?$form['type_name']['#value']:"Default");

  // build the table with all the fields if no $tid is given, or only the common
  // and customized fields if $tid is given
  $conf_table = array();
  foreach(element_children($form['configured_flds']) as $fld) {
    $conf_row = array();
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['name']));
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['title']),'align' => 'center');
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['hint']),'align' => 'center');
    foreach (element_children($form['configured_flds'][$fld]['checkboxes']) as $oid) {
      if (is_array($form['configured_flds'][$fld]['checkboxes'])) {
            $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['checkboxes'][$oid]), 'align' => 'center', 'title' => $oid);
      }
    }
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['weight']),'align' => 'center');
    if ($tid) {
      if ($form['cust'][$fld]) {
        $conf_row[] = array('data' => l('remove',"$base/type/remove/$tid/$fld"),'align' => 'left');
      }else{
        $conf_row[] = array('data' => "common",'align' => 'left');
      }
    }
   $conf_table[] = $conf_row;
  }
  if ($tid) {
    $header =array(t('Field Name'),t('Default Title'),t('Hint'),t('Required'),t('Weight'),t('Action'));
  }else{
    $header =array(t('Field Name'),t('Default Title'),t('Hint'),t('Common'),t('Required'),t('Autocomplete'),t('Weight'));

  }


  $output .= '<p>';
  drupal_add_js('misc/collapse.js');
  $output .= '<p><fieldset class=" collapsible"><legend>Currently configured fields</legend>';
  $output .= theme('table',$header,$conf_table);
  $output .= '<p><center>'.drupal_render($form['submit']).'</center></p>';
  $output .= '</fieldset>';

  if ($tid) {
    $avail_table = array();

    foreach(element_children($form['avail_flds']) as $fld) {
      $avail_row = array();

      $avail_row[] = array('data' => '<div>'.drupal_render($form['avail_flds'][$fld]['name']).'</div>');
      $avail_row[] = array('data' => '<div>'.drupal_render($form['avail_flds'][$fld]['size']).'</div>','align' => 'left');
      $avail_row[] = array('data' => '<b>'.drupal_render($form['avail_flds'][$fld]['title']).'</b>','align' => 'left');
      $avail_row[] = array('data' => l('add',"$base/type/add/$tid/$fld"),'align' => 'left');
      $avail_table[] = $avail_row;
    }

    $header2 =array(array('data'=>'Field Name','align'=>'right'),'Size','Default Name','Action');

    $output .= '<p><fieldset class=" collapsible"><legend>' . t('Other available fields') .'</legend>';
    $output .= theme('table',$header2,$avail_table);
    $output .= '<p><center>'.drupal_render($form['add']).'</center></p>';
    $output .= '</fieldset>';
  }
  $output .= drupal_render($form);
  return $output;

}
function biblio_type_add($tid=0,$fid=0) {
   $result = db_query("SELECT fid,title,weight,required,hint FROM {biblio_fields} WHERE fid=%d",$fid);
   if ($fld = db_fetch_object($result)) {
     db_query("INSERT INTO {biblio_type_details} (tid, fid, title, weight, required, hint)
                   VALUES (%d,%d,'%s',%d,%d,'%s')",$tid,$fid,$fld->title,$fld->weight,$fld->required,$fld->hint);
   }
  drupal_goto("admin/settings/biblio/types/edit/$tid");
}
function biblio_type_remove($tid=0,$fid=0) {

  db_query('DELETE FROM {biblio_type_details} WHERE tid = %d AND fid = %d', $tid,$fid);

  drupal_goto("admin/settings/biblio/types/edit/$tid");
}
function biblio_form_types_edit_submit($form_id, $edit) {
  $tid = $edit['tid']?$edit['tid']:false;

  if ($tid) {
    $type_query = "UPDATE {biblio_type_details} SET
                      title = '%s' , weight = %d ,
                      hint = '%s' , required = %d
                      WHERE fid = %d AND tid = %d";
  }else{
    $field_query = "UPDATE {biblio_fields} SET title = '%s', weight = %d,
                    common = %d, required = %d, autocomplete = %d, hint = '%s' WHERE fid = %d";
  }

  foreach ($edit['configured_flds'] as $key=>$v) {
    $common = ($v['checkboxes']['common'])?TRUE:FALSE;
    $required = ($v['checkboxes']['required'])?TRUE:FALSE;
    $autocomplete = ($v['checkboxes']['autocomplete'])?TRUE:FALSE;
    if (is_numeric($key) ) {
      if ($tid && $edit['cust'][$key]) { // is type and not a common field update biblio_type_details
        db_query($type_query, $v['title'],$v['weight'],$v['hint'],$required,$key,$tid);
      }elseif (!$tid) { // is a common field, update the biblio_field table
        db_query($field_query, $v['title'],$v['weight'],$common,$required,$autocomplete,$v['hint'],$key);
      }
    }
 }

  drupal_set_message(t("The changes have been saved."));

  // Clear the cached pages and menus:
  menu_rebuild();
// drupal_goto('admin/settings/biblio/types');

}
function _biblio_form_sort($a, $b) {
  $a_weight = (is_array($a) && isset($a['weight'])) ? $a['weight'] : 0;
  $b_weight = (is_array($b) && isset($b['weight'])) ? $b['weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

function biblio_filter_clear() {
  $_SESSION['biblio_filter'] = array();
  $base =  variable_get('biblio_base', 'biblio');
  drupal_goto($base);
}

function _get_biblio_filters() {
  $fields = " b.biblio_year, b.biblio_authors, t.name , t.tid ";
  $order = " b.biblio_year DESC";
  $taxo_fields = "td.name as termname,td.tid as taxid, v.name as vocab_name";
  $taxo_order = "vocab_name ASC, termname ASC";
  $table = "{node} as n  inner join {biblio} as b on n.vid=b.vid ";
  $join = "left join {biblio_types} as t on b.biblio_type = t.tid";
  $taxo_join = array("inner join {term_node} as tn on n.nid = tn.nid",
                     "left join  {term_data} as td on tn.tid= td.tid",
                     "left join  {vocabulary} as v on v.vid= td.vid");

  $taxo_joins = implode(' ',$taxo_join);

  $result = db_query("SELECT $fields FROM $table $join ORDER BY $order");
  $taxoresult = db_query("SELECT $taxo_fields FROM $table $taxo_joins ORDER BY $taxo_order");

  while ($option = db_fetch_object($result)) {
    if ($option->biblio_year == 9998) { $option->biblio_year = t("In Press"); }
    if ($option->biblio_year == 9999) { $option->biblio_year = t("Submitted"); }
    $pub_years["$option->biblio_year"] = $option->biblio_year;
    $pub_type["$option->tid"] = $option->name;

    $author_array = explode(";", $option->biblio_authors);
    foreach($author_array as $auth) {
      if (strstr($auth, ",")) {
        $parts = split(",", $auth);
        $lastname = trim($parts[0]);
      } else {
        $parts = split(" ", $auth);
        $lastname = trim(end($parts));
      }
      if ($lastname) $pub_authors["$lastname"] = $lastname;
    }
  }
  while ($tax = db_fetch_object($taxoresult)) {
    $pub_taxo["$tax->taxid"] = "$tax->vocab_name - $tax->termname";
  }

  $pub_years = array_unique($pub_years);
  $pub_type = array_unique($pub_type);
  if (!empty($pub_taxo))$pub_taxo = array_unique($pub_taxo);

  if (!empty($pub_taxo)) {
    $tax_select =  array('title' => t('Term'),'options' => $pub_taxo);
  }else{$tax_select = null;
  }

  ksort($pub_authors);
  $filters = array(
    'author' => array('title' => t('Author'),'options' => $pub_authors),
    'type' => array('title' => t('Type'),'options' => $pub_type),
    'term_id' => $tax_select,
    'year' => array('title' => t('Year'),'options' => $pub_years)
  );

  return $filters;
}

function biblio_form_filter() {
  $session = &$_SESSION['biblio_filter'];
  $session = is_array($session) ? $session : array();
  $filters = _get_biblio_filters();

   $i = 0;
  $form['filters'] = array('#type' => 'fieldset',
    '#title' => t('Show only items where'),
    '#theme' => 'biblio_filters',
  );
  foreach ($session as $filter) {
    list($type, $value) = $filter;
    if ($type == 'category') {
      // Load term name from DB rather than search and parse options array.
      $value = module_invoke('taxonomy', 'get_term', $value);
      $value = $value->name;
    }else if ($type == 'keyword') {
      $filters[$type]['title'] = 'Keyword';
    }else {
      $value = $filters[$type]['options'][$value];
    }
    $string = ($i++ ? '<em>and</em> where <strong>%a</strong> is <strong>%b</strong>' : '<strong>%a</strong> is <strong>%b</strong>');
    $form['filters']['current'][] = array('#value' => t($string, array('%a' => $filters[$type]['title'] , '%b' => $value)));
  }

  foreach ($filters as $key => $filter) {
    if (count ($filter['options'])) {
    $names[$key] = $filter['title'];
    $form['filters']['status'][$key] = array('#type' => 'select', '#options' => $filter['options']);
   }
  }
  $form['filters']['status']['keyword']=array('#type' => 'textfield','#size' => 25, '#maxlength' => 255);
  $names['keyword'] = "Keyword";

  $form['filters']['filter'] = array('#type' => 'radios', '#options' => $names, '#default_value' => 'status');
  $form['filters']['buttons']['submit'] = array('#type' => 'submit', '#value' => (count($session) ? t('Refine') : t('Filter')));
  if (count($session)) {
    $form['filters']['buttons']['undo'] = array('#type' => 'submit', '#value' => t('Undo'));
    $form['filters']['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset'));
  }

  return  $form;
}
function theme_biblio_filters(&$form) {

  if (sizeof($form['current'])) {
    $output .= '<ul>';
    foreach (element_children($form['current']) as $key) {
      $output .= '<li>' . drupal_render($form['current'][$key]) . '</li>';
    }
    $output .= '</ul>';
  }

  $output .= '<dl class="multiselect">' . (sizeof($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') . '<dd class="a">';
  foreach (element_children($form['filter']) as $key) {
    $output .= drupal_render($form['filter'][$key]);
  }
  $output .= '</dd>';

  $output .= '<dt>'. t('is') .'</dt>' . '<dd class="b">';

  foreach (element_children($form['status']) as $key) {
    $output .= drupal_render($form['status'][$key]);
  }
  $output .= '</dd>';

  $output .= '</dl>';
  $output .= '<div class="container-inline" id="node-buttons">'. drupal_render($form['buttons']) .'</div>';
  $output .= '<br class="clear" />';

  return $output;
}

function biblio_form_filter_submit($form_id,$form_values) {
  //global $form_values;
  $op = $form_values['op'];
  $filters = _get_biblio_filters();
  switch ($op) {
    case t('Filter'):
    case t('Refine'):
      if (isset($form_values['filter'])) {
        $filter = $form_values['filter'];

        // Flatten the options array to accommodate hierarchical/nested options.
        if (isset($filters[$filter]['options'])) {
          $flat_options = form_options_flatten($filters[$filter]['options']);
        }

        if (isset($flat_options[$form_values[$filter]]) || $filter == 'keyword') {
          $_SESSION['biblio_filter'][] = array($filter, $form_values[$filter]);
          $base =  variable_get('biblio_base', 'biblio');
          drupal_goto($base);

        }
      }
      break;
    case t('Undo'):
      array_pop($_SESSION['biblio_filter']);
      break;
    case t('Reset'):
      $_SESSION['biblio_filter'] = array();
      break;
  }
}
function theme_biblio_form_filter(&$form) {

  $output .= '<div id="biblio-admin-filter">';
  $output .= drupal_render($form['filters']);
  $output .= '</div>';
  $output .= drupal_render($form);
  return $output;
}

/*function theme_biblio_node_form($form) {
echo "in node form";die;
}
*/
function biblio_submit(&$node) {
  if (!is_numeric($node->biblio_year)) {
    if ( drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("In Press")) )  {
        $node->biblio_year = 9998;
    }
    if (drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("Submitted")) ) {
       $node->biblio_year = 9999;
    }
  }
  if (variable_get('biblio_keyword_freetagging',0) && variable_get('biblio_freetagging_vocab',0)) {
    $vid = variable_get('biblio_freetagging_vocab',0);
    $node->taxonomy['tags'][$vid] = $node->biblio_keywords;
  }
}
//function biblio_pre_render($form_id, &$form, $next_page = TRUE) {
function biblio_form_alter($form_id, &$form) {
  global $form_values;
  if ($form_id == "biblio_node_form") {
    if (!empty($form['#node']->biblio_type)) $type = $form['#node']->biblio_type;
    if (!empty($form['#post']['biblio_type'])) $type = $form['#post']['biblio_type'];
    //$type = $form['#post']['biblio_type'] ? $form['#post']['biblio_type']:;

    if ( $type >0 ) {

    $form['title']['#type'] = 'textfield';

    if (variable_get('biblio_input_full_text', 1)) $form['body']['#type'] = 'textarea';

    $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
    while ($row = db_fetch_array($result)) {
        $fields[$row['fid']] = $row;
        if ($row['common']) $form[$row['name']]['#type'] = $row['type'];
    }

    $result = db_query('SELECT b.*, c.name, c.type FROM {biblio_type_details} as b INNER JOIN {biblio_fields} as c ON b.fid = c.fid where tid= %d ORDER BY b.weight ASC',$type);
    while ($row = db_fetch_array($result)) {
      $type_fields[$row['fid']] = $row;
      $form[$row['name']]['#type'] = $row['type'];
    }

    if (count($type_fields)) {
    // now merge the customizations with the main field array
      foreach($type_fields as $key=>$value) {
        $fields[$key] = array_merge($fields[$key],$value);
      }
    }

    foreach ($fields as $key=>$fld) {

      $form[$fld['name']] = array_merge($form[$fld['name']],array(
                                          '#default_value' =>$form['#node']->$fld['name'],
                                          '#title' => $fld['title'],
                                          '#required' => $fld['required'],
                                          '#size' => $fld['size'],
                                          '#maxlength' => $fld['maxsize'],
                                          '#weight' => $fld['weight']/10,
                                          '#description' => $fld['hint'])
                                        ); // end array_merge

    } //end foreach
    $form['biblio_keywords']['#description'] = t("Separate key words with a <b>!sep</b> character", array('!sep' => variable_get('biblio_keyword_sep', ',')));

  } //endif type > 0
 } //endif ($form_id == 'biblio_node_form...
 return $form;

}


/**
* Implementation of hook_form().
*
* Create the form for collecting the information
* specific to this node type. This hook requires us to return some HTML
* that will be later placed inside the form.
*/
function biblio_form(&$node, &$param) {
  global $form_values;
  $output = '';
  $param['options'] = array("enctype" => "multipart/form-data");

  //$form['#pre_render'] = array('biblio_pre_render');

  $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE tid > -2 AND visible = 1');
  while ($option = db_fetch_object($result)) {
    $options["$option->tid"] = $option->name;
  }

  $form['biblio_type'] = array(
    '#type' => 'select',
    '#title' => t('Publication Type'),
    '#default_value' => $node->biblio_type,
    '#options' => $options,
    '#description' => null,
    '#weight' => -5,
    '#attributes' => array('onchange'=>'document.getElementById(\'node-form\').submit()'),
    '#multiple' => false, '#required' => true);

  $form['title']= array( // this will be set to textfield type in pre_render once the pub type is set.
    '#type' => 'value',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#size' => 60,
    '#maxlength' => 255,
    '#weight' => -4
  );

    // Build the field array used to make the form
    $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
    while ($row = db_fetch_array($result)) {
     // if ($row['common']) {
        $fields[$row['fid']] = $row;
     // }
    }

    // Now set all the fields to "value" type so the will not be visible, and
    // then in biblio_pre_render the correct type will be set.
    foreach ($fields as $key=>$fld) {
          $form[$fld['name']] = array(
          '#default_value' => $node->$fld['name'],
          '#type' => 'value',
          '#title' => $fld['title'],
          '#size' => $fld['size'],
          '#required' => $fld['required'],
          '#maxlength' => $fld['maxsize'],
          '#weight' => $fld['weight']/10,
          '#autocomplete_path' => ($fld['autocomplete']) ? 'biblio/autocomplete/'.$fld['name'] : '',
          '#description' => $fld['hint']
        );

    }
 /*   $form['authors1'] = array('#type' => 'fieldset',
                              '#title' => t('First Authors'),
                              '#collapsible' => TRUE,
                              '#collapsed' => TRUE,
                              '#weight' => 0);
    $form['authors1']['author1_lastname'] = array(
          '#default_value' => $node->$fld['name'],
          '#type' => 'textfield',
          '#title' => t('lastname'),
          '#size' => 20,
          '#required' => 1,
          '#maxlength' => 75,
          '#weight' => 1,
          '#description' => ''
        );

    $form['authors2'] = array('#type' => 'value',
                              '#title' => t('More Authors...'),
                              '#collapsible' => TRUE,
                              '#collapsed' => TRUE,
                              '#weight' => 0);
  */

  if (variable_get('biblio_input_full_text', 1)) {
    $form['body'] = array('#type' => 'value',
                               '#title' => t('Full Text'),
                               '#default_value' => $node->body,
                               '#rows' => 10, '#required' => FALSE,
                               '#description' => t('You may enter a full text or HTML version of the publication here.'),
                               '#weight' => 19);
    $form['format'] = filter_form($node->format,20);
  }

 return $form;
}

/**
* Implementation of hook_validate().
*
*
* Errors should be signaled with form_set_error().
*/
function biblio_validate(&$node) {

  if ($node->biblio_type == 0) {
    form_set_error('biblio_type', t('You must select the type of publication'));
    return;
  }
  if (!$node->biblio_authors) {
    form_set_error('biblio_authors', t('You must supply at least one author name'));
  }
  /*  if (!strstr("$node->biblio_authors", ";")) {
    form_set_error('biblio_authors', t('You must separate the author names with semicolons'));
  }
*/
  if (!isset($node->biblio_year)) {
    form_set_error('biblio_year', t('You must supply the year of publication'));
  }
  if ( !is_numeric($node->biblio_year) && $node->biblio_year != t("In Press") && $node->biblio_year != t("Submitted") )
  {
    form_set_error('biblio_year', t('Year of Publication must be a number between 1 and @thisyear or the words "In Press" or "Submitted" ', array('@thisyear' => $today['year']+1)));

  }
  $today = getdate();
  if ( is_numeric($node->biblio_year) && ($node->biblio_year < 1 || $node->biblio_year > $today['year']+1)) {
    form_set_error('biblio_year', t('Year of Publication must be a number between 1 and @thisyear', array('@thisyear' => $today['year'])));
  }

  /*  if (!$node->biblio_secondary_title) {
    form_set_error('biblio_secondary_title', t('You must supply the Journal Title, Conference Name or Book Title'));
  }
*/

}
function biblio_insert_authors($nid, $authors=array() ) {

}
/**
* Implementation of hook_insert().
*
* As a new node is being inserted into the database, we need to do our own
* database inserts.
*/
function biblio_insert($node) {
  // Prepare the query:
  $fields = biblio_get_db_fields();
  if (variable_get('biblio_auto_citekey', 1) && empty($node->biblio_citekey)) $node->biblio_citekey = biblio_citekey_generate($node);
  $node->biblio_coins = biblio_coins($node);

  foreach ($node as $key => $value) {
    if (in_array((string) $key, $fields)) {
      $k[] = db_escape_string($key);
      $v[] = $value;
      $s[] = "'%s'";
    }
  }
  // Insert the node into the database:
  db_query("INSERT INTO {biblio} (" . implode(", ", $k) . ") VALUES(" . implode(", ", $s) . ")", $v);
}

/**
* Implementation of hook_update().
*
* As an existing node is being updated in the database, we need to do our own
* database updates.
*/
function biblio_update($node) {
  $fields = biblio_get_db_fields();
  $node->biblio_coins = biblio_coins($node);
  if (variable_get('biblio_auto_citekey', 1) && empty($node->biblio_citekey)) $node->biblio_citekey = biblio_citekey_generate($node);
  if (!is_numeric($node->biblio_year)) {
    if ( drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("In Press")) )  {
        $node->biblio_year = 9998;
    }
    if (drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("Submitted")) ) {
       $node->biblio_year = 9999;
    }
  }

  foreach ($node as $key => $value) {
    if (in_array($key, $fields) && $key !="0") { //$key != "0" to fix a bug related to book module
      $k[] = db_escape_string($key);
      $q[] = end($k) . " = '%s'";
      $v[] = $value;
      $s[] = "'%s'";
    }
  }
  // Update the node in the database:
  if ($node->revision) {
    db_query("INSERT INTO {biblio} (" . implode(", ", $k) . ") VALUES(" . implode(", ", $s) . ")", $v);
  }else{
    db_query("UPDATE {biblio} SET " . implode(', ', $q) . " WHERE vid = '$node->vid'", $v);
  }
}

/**
* Implementation of hook_delete().
*
* When a node is deleted, we need to clean up related tables.
*/
function biblio_delete($node) {
  db_query('DELETE FROM {biblio} WHERE nid = %d', $node->nid);
}

/**
* Implementation of hook_load().
*
* This hook is called
* every time a node is loaded, and allows us to do some loading of our own.
*
*/
function biblio_load($node) {
  $additions = db_fetch_object(db_query('SELECT b.*, bt.name as biblio_type_name FROM {biblio} b left join {biblio_types} bt on b.biblio_type = bt.tid WHERE b.vid = %d', $node->vid));
  if ( $additions->biblio_year == 9998)  {
        $additions->biblio_year = t("In Press");
    }
    if ($additions->biblio_year == 9999) {
       $additions->biblio_year = t("Submitted");
    }
  return $additions;
}

function biblio_citekey_view() {
  $citekey = arg(2);
  $nid = db_fetch_object(db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = '%s' ORDER BY vid DESC", $citekey));
  if ($nid->nid > 0) {
    $node = node_load($nid->nid);
    return node_page_view($node);
  } else {
    return t("Sorry, citekey @cite not found", array('@cite'=>$citekey));
  }

}

function biblio_citekey_generate($node)
{
 $prefix = variable_get('biblio_citekey_prefix', '');
 $primary_field = variable_get('biblio_citekey_field1', 'nid');
 $secondary_field = variable_get('biblio_citekey_field2', 'nid');
 $citekey = (!empty($node->$primary_field))?$node->$primary_field:(!empty($node->$secondary_field)?$node->$secondary_field:$node->nid);
 return $prefix.$citekey;
}


function biblio_view_inline(&$node) {
  $style = variable_get('biblio_style', 'classic');
  $base =  variable_get('biblio_base', 'biblio');

  $output  = '<div class="biblio-inline">';
  $output .= theme('biblio_long', $node, $base, $style);
  $output .= '</div>';
  print $output;
}
/**
* Implementation of hook_view().
*
* This is a typical implementation that simply runs the node text through
* the output filters.
*/
function biblio_view(&$node, $teaser = false, $page = false) {
  theme('biblio_add_css');
  if ( strlen(trim($node->body)) ) $node = node_prepare($node, $teaser);

  $style = variable_get('biblio_style', 'classic');
  $base =  variable_get('biblio_base', 'biblio');
  switch (variable_get('biblio_node_layout', '0')) {
  case 'orig':
  case 'ft':
    $node->content['body']['#value'] = theme('biblio_long', $node,$base,$style);
    break;
  case 'tabular':
  default:
    $node->content['body']['#value'] = biblio_show_node($node, $base, $teaser);
    break;
  }

  if ($page) {
    drupal_set_breadcrumb(array(l(t('Home'), NULL), l(drupal_ucfirst($base), $base)));
  }

  return $node;

}

/**
* Implementation of hook_block().
*
* Generates a block containing the latest poll.
*/
function biblio_block($op = 'list', $delta = 0) {
  if (user_access('access content')) {
    if ($op == 'list') {
      $blocks[0]['info'] = t('Most recent publications');
      return $blocks;
    } else if ($op == 'view') {
      // Retrieve the latest pubs
      $num_in_block = variable_get('biblio_rowsperblock', 4);
      $block_order  = variable_get('biblio_block_order', 'n.created');
      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.status, b.biblio_year FROM {node} n left join {biblio} b  on n.vid=b.vid WHERE n.type = 'biblio' AND n.status=1 ORDER BY $block_order DESC"), 0, $num_in_block);
      if (db_num_rows($result)) {
        $base =  variable_get('biblio_base', 'biblio');
        $block['subject'] = t(variable_get('biblio_block_title', 'New Publications'));
        $block['content'] .= '<div class="item-list"><ul>';
        while ($pub = db_fetch_object($result)) {
          $block['content'] .= '<li >' . l("$pub->title", "node/$pub->nid") . '</li>';
        }
        $block['content'] .= '</ul>';
        if (variable_get('biblio_rss', 0)) {
          $block['content'] .=  theme('feed_icon', url("$base/rss.xml"));
        }
        $block['content'] .= '</div>';
      }
      return $block;
    }
  }
}

function biblio_feed($result = null, $title = null) {

  if (empty($result)) $result = db_query_range(db_rewrite_sql("SELECT n.nid,n.title,n.created,b.* FROM {node} AS n left join {biblio} b  on n.vid=b.vid WHERE n.type = 'biblio' AND n.status=1 ORDER BY n.created DESC"), 0, variable_get('biblio_rss_number_of_entries',10));
  $channel['title'] = $title ? $title : variable_get('site_name', 'Drupal') .' - '. t("New Publications");
  node_feed($result, $channel);

}

function theme_biblio_long($node,$base='biblio',$style='classic') {

  if (empty($node->biblio_coins)) biblio_coins_generate($node);
  $output .= $node->biblio_coins;
  $layout = variable_get('biblio_node_layout', 'orig');
  if (variable_get('biblio_node_layout', 'orig') == 'ft' && strlen(trim($node->body)) && user_access('view full text') ) {
    $output .= '<div class="biblio-head">'.theme('biblio_short', $node,$base,$style).'</div>';
    $annotation_field = variable_get('biblio_annotations','none');
    if ($annotation_field != 'none' && $node->$annotation_field) {
      $output .= '<div class="biblio_annotation">';
      $output .= check_markup($node->$annotation_field, $node->format, FALSE);
      $output .= '</div>';
    }
    $output .= check_markup($node->body, $node->format, FALSE) ;
    if ( biblio_access('export',$node)) {
      $output .= theme('biblio_export_links',$node->nid);
    }
    return $output;
  }

  if (variable_get('biblio_normalize', 0)) {
    $authors = _biblio_parse_authors($node->biblio_authors);
  } else {
    $authors = $node->biblio_authors;
  }

  $openurl_base = variable_get('biblio_baseopenurl','');

  if ($openurl_base) $output .= theme('biblio_openurl',biblio_openurl($node, $openurl_base));


  $output .= '<div class="biblio_type"><h3>'.t("Publication Type").":</h3> $node->biblio_type_name</div>\n";
  $output .= '<div class="biblio_authors"><h3>'.t("Authors").':</h3> ' . _biblio_author_links($authors,$base) . "</div>\n";
  $output .= '<div class="biblio_source"><h3>'.t("Source").': </h3> ';
  $source = null;
  if ($node->biblio_secondary_title) $source .= check_plain($node->biblio_secondary_title);
  if ($node->biblio_publisher) {
    $source .= $source?", ":"";
    $source .= check_plain($node->biblio_publisher);
  }
  if ($node->biblio_volume) {
    $source .= $source?", ":"";
    $source .= t('Volume ') . check_plain($node->biblio_volume);
  }
  if ($node->biblio_issue) {
    $source .= $source?", ":"";
    $source .= t('Issue ') . check_plain($node->biblio_issue);
  }
  if ($node->biblio_number) {
    $source .= $source?", ":"";
    $source .= t('Number ') . check_plain($node->biblio_number);
  }

  if ($node->biblio_place_published) {
    $source .= $source?", ":"";
    $source .= check_plain($node->biblio_place_published);
  }
  if ($node->biblio_pages) {
    $source .= $source?", ":"";
    $source .= 'p.' . check_plain($node->biblio_pages);
  }
  if (isset($node->biblio_year)) {
    if ($node->biblio_year == 9998) { $node->biblio_year = t("In Press"); }
    if ($node->biblio_year == 9999) { $node->biblio_year = t("Submitted"); }
    $source .= ' (' . check_plain($node->biblio_year) . ')';
  }
  $output .= "$source</div>\n";

  if ($node->biblio_isbn) $output .= '<h3>'.t("ISBN").':</h3> ' . check_plain($node->biblio_isbn) . "\n";
  if ($node->biblio_call_number) $output .= '<h3>'.t("Call Number").':</h3> ' . check_plain($node->biblio_call_number) . "\n";
  if ($node->biblio_accession_number) $output .= '<h3>'.t("Accession Number").':</h3> ' . check_plain($node->biblio_accession_number) . "\n";
  if ($node->biblio_other_number) $output .= '<h3>'.t("Other Number").':</h3> ' . check_plain($node->biblio_other_number) . "\n";
  if ($node->biblio_url) {
      $attrib = (variable_get('biblio_links_target_new_window',null)) ? array('target'=>'_blank') : null;
      $output .= '<h3>'.t("URL").':</h3>'.l("$node->biblio_url",$node->biblio_url,$attrib) . "\n";
  }
  if ($node->biblio_keywords) $output .= '<h3>'.t("Keywords").':</h3> ' . _biblio_keyword_links($node->biblio_keywords,$base) . "\n";
  if ($node->biblio_abst_e) $output .= '<h3>'.t("Abstract").':</h3> ' . check_markup($node->biblio_abst_e, $node->format, FALSE) . "\n";
  if ($node->biblio_abst_f) $output .= '<p>' . check_markup($node->biblio_abst_f, $node->format, FALSE) . "\n";
  if ($node->biblio_notes) $output .= '<h3>'.t("Notes").': </h3>' . check_markup($node->biblio_notes, $node->format, FALSE) . "\n";
  if ( strlen(trim($node->body)) && user_access('view full text') ) {
     $output .= '<h3>'.t('Full Text').':</h3>'.check_markup($node->body, $node->format, FALSE);
  }
  if ( biblio_access('export',$node)) {
    $output .= theme('biblio_export_links',$node->nid);
  }

  return $output;
}

function theme_biblio_export_links($nid) {
//     $output .= '<br /><br />Export: ['.l(t("Tagged"),"$base/export/tagged/$node->nid").']';
//     $output .= '['.l(t("XML"),"$base/export/xml/$node->nid").']';
//     $output .= '['.l(t("BibTex"),"$base/export/bib/$node->nid").']<br /><br />';
  $base =  variable_get('biblio_base', 'biblio');
  $links .= '<p /><ul class="tabs secondary">';
  $links .= '<li> '.l(t("Tagged"),"$base/export/tagged/$nid").'</li>';
  $links .= '<li> '.l(t("XML"),"$base/export/xml/$nid").'</li>';
  $links .= '<li> '.l(t("BibTex"),"$base/export/bib/$nid").'</li></ul>';

  return $links;
}

function theme_biblio_short($node, $base='biblio', $style_name='classic', $inline=false) {
 // $style_name = $style ? $style : variable_get('biblio_style', 'classic');
  require_once( drupal_get_path('module', 'biblio') . "/biblio_style_$style_name.inc");
  $style_function = "biblio_style_$style_name";
  $styled_node = $style_function($node, $base, $inline);
  if (empty($node->biblio_coins)) biblio_coins_generate($node);
  return($styled_node.$node->biblio_coins);

}
function theme_biblio_list($node, $base='biblio', $style='classic', $inline=false) {

  $output .= theme('biblio_short', $node, $base, $style, $inline);
  if ($node->biblio_abst_e) {
    $output .= '<span class="biblio_abstract_link">';
    $output .= l(" Abstract", "node/$node->nid") . "\n";
    $output .= '</span>';
  }

  $annotation_field = variable_get('biblio_annotations','none');
  if ($annotation_field != 'none' && $node->$annotation_field) {
    $output .= '<div class="biblio_annotation">';
    $output .= check_markup($node->$annotation_field,FILTER_HTML_ESCAPE,FALSE);
    $output .= '</div>';
  }

  $openurl_base = variable_get('biblio_baseopenurl','');
  if ($openurl_base) $output .= theme('biblio_openurl',biblio_openurl($node));

  if ( biblio_access('export',$node)) {
    $base =  variable_get('biblio_base', 'biblio');
    $output .= '<br/>&nbsp;'. t('Export') .':&nbsp;';
    $output .= '<span class="biblio_export_links">';
    $output .= l("Tagged","$base/export/tagged/$node->nid") . '&nbsp;';
    $output .= l("XML","$base/export/xml/$node->nid") . '&nbsp;';
    $output .= l("BibTex","$base/export/bib/$node->nid") ;
    $output .= '</span>';
  }
  if ( biblio_access('download',$node)) {
    // add links to attached files (if any)
    if ( !empty($node->files) && count($node->files) > 0 && user_access('view uploaded files') ) {
      $output .= '&nbsp;&nbsp;&nbsp;'. t('Download') .':&nbsp;';
      $output .= '<span class="biblio_export_links">';
      foreach ($node->files as $file) {
        $output .= '&nbsp;'. l($file->filename, $file->filepath). '&nbsp;';
      }
      $output .= '</span>';
    }
  }
  return $output;
}

function theme_biblio_add_css() {
  drupal_add_css(drupal_get_path('module', 'biblio').'/biblio.css');
}

function biblio_show_results($result, $attrib = array("sort" => 'year', 'order' => 'DESC'), $args = null,$inline=false) {
  global $pager_total_items;
  $base =  variable_get('biblio_base', 'biblio');
  $style = variable_get('biblio_style', 'classic');
  theme('biblio_add_css');
  if (variable_get('biblio_rss', 0)) {
    drupal_set_html_head('<link rel="alternate" type="application/rss+xml" title="'.variable_get('site_name', 'Drupal').' RSS" href="'.url("$base/rss.xml").'" />');
  }
  $pub_types = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid>0');
  while ($option = db_fetch_object($pub_types)) {
    $pub_type["$option->tid"] = $option->name;
  }
  if (!$inline) {
    // Add some links to the top of the page to change the sorting/ordering...
    if ( biblio_access('export')) {
      $content .= '<div class="biblio_record_count">'.t('Found @count results', array('@count' => $pager_total_items[0])).'</div><div class="biblio_export"> Export:['.l("Tagged","$base/export/tagged"). ']['.l("XML","$base/export/xml"). ']['.l("BibTex","$base/export/bib").']</div>';
    }else{
      $content .= '<div class="biblio_record_count">'.t('Found @count results', array('@count' => $pager_total_items[0])) .'</div><br />';
    }
    if (user_access('show sort links')) {
      $sort_attr = array("title"=>t("Click a second time to reverse the sort order"));

      $sort_links =  variable_get('biblio_sort_tabs', array('author'=>'author','title'=>'title','type'=>'type','year'=>'year'));
      $query = NULL;
      foreach ($_GET as $key => $value ){
          if ($key != 'q' && $key != 'sort' && $key != 'order')
          {
            $query .= $key.'='.$value; // $query will contain any addional URL query elements not related to this module
          }
      }
      if (!empty($query)) $query = '&'.$query;

      if ( count(array_filter($sort_links)) ) {
        $content .= '<div class="biblio_sort">';
        $content .= t('Sort by').':';
        if ($sort_links['year']) {
          $order = ($attrib['sort'] == 'year')?(($attrib['order'] == "desc" )?'asc':'desc'):'desc';
          $content .= "[".l(t("Year"),$_GET['q'],$sort_attr,"sort=year&order=$order$query")."]";
        }
        if ($sort_links['title']){
          $order = ($attrib['sort'] == 'title')?(($attrib['order'] == "desc" )?'asc':'desc'):'asc';
          $content .= "[".l(t("Title"),$_GET['q'],$sort_attr,"sort=title&order=$order$query")."]";
        }
        if ($sort_links['type']){
          $order = ($attrib['sort'] == 'type')?(($attrib['order'] == "desc" )?'asc':'desc'):'asc';
          $content .= "[".l(t("Type"),$_GET['q'],$sort_attr,"sort=type&order=$order$query")."]";
        }
        if ($sort_links['author']){
          $order = ($attrib['sort'] == 'author')?(($attrib['order'] == "desc" )?'asc':'desc'):'asc';
          $content .= "[".l(t("Author"),$_GET['q'],$sort_attr,"sort=author&order=$order$query")."]";
        }
        if ($sort_links['keyword']){
          $order = ($attrib['sort'] == 'keyword')?(($attrib['order'] == "desc" )?'asc':'desc'):'asc';
          $content .= "[".l(t("Keyword"),$_GET['q'],$sort_attr,"sort=keyword&order=$order$query")."]";
        }
        $content .= "</div> ";
      }
    }

    $session = &$_SESSION['biblio_filter'];
    // if there are any filters in place, print them at the top of the list
    if (count($args)) {
      $content .= '<div class="biblio-current-filters"><b>'.t('Filters').': </b>';
      while ($args) {
        $type = $args[0];
        array_shift($args);
        $value = db_escape_string($args[0]);
        if ($type == 'term_id') {
          $term = taxonomy_get_term($value);
          $value = $term->name;
          $type = t("Taxonomy Term");
        }
        if ($type == 'type') $value = $pub_type["$value"];
        array_shift($args);
        $params = array('%a' =>  $type , '%b' =>  $value );
        $content .= ($i++ ? t('<em> and</em> <strong>%a</strong> is <strong>%b</strong>', $params) : t('<strong>%a</strong> is <strong>%b</strong>', $params)) ;
      }
      if ($inline != 'profile'){
        $content .= '&nbsp;&nbsp;'.l('['.t('Clear All Filters').']',"$base/filter/clear");
        $content .= '</div>';
      }
    }
  }
  if ($inline === true) print '<div class="biblio-inline">';
  $_char = $_type = $_year = $name = "";
  while ($node = db_fetch_object($result)) {
    // to add links to attached files (if any)
    // we need the node->files array
    if ( module_exists("upload") ) {
      $node->files = upload_load($node);
    }

    if (isset($node->biblio_year) && ($node->biblio_year == 9998))  $node->biblio_year = t("In Press") ;
    if (isset($node->biblio_year) && ($node->biblio_year == 9999))  $node->biblio_year = t("Submitted") ;
    switch ($attrib['sort']) {
      case 'title':
        if ( drupal_substr(drupal_ucfirst(ltrim($node->title)), 0, 1)  != $_char) {
          $_char =  drupal_substr(drupal_ucfirst(ltrim($node->title)), 0, 1) ;
          $content .= '<div class="biblio-year">' . $_char . "</div>\n";
        }
        break;
      case 'author':
        if ( drupal_substr(drupal_ucfirst(ltrim($node->biblio_authors)), 0, 1) != $_char) {
          $_char = drupal_substr(drupal_ucfirst(ltrim($node->biblio_authors)), 0, 1) ;
          $content .= '<div class="biblio-year">' . $_char . "</div>\n";
        }
        break;
      case 'type':
        if ($node->biblio_type_name != $_type) {
          $_type = $node->biblio_type_name;
          //$name = db_result(db_query("SELECT name FROM {biblio_types} as t where t.tid=%d", $node->biblio_type)) ;
          $content .= '<div class="biblio-year">' . $_type . "</div>\n";
        }
        break;
      case 'keyword': 	// added msh 08 aug 07
        $tok = drupal_ucfirst(strtok($node->biblio_keywords, variable_get('biblio_keyword_sep', ',')));
        if (empty($tok)) {
          $tok = t("No Keywords");
        }
        if ($tok != $name) {
          $name = $tok;
          if ($name != '') {
            $content .= '<div class="biblio-year">' . $name . "</div>\n";
          }
        }
        break;
      case 'year':
      default:
        if ($node->biblio_year != $_year) {
          $_year = $node->biblio_year;
          $content .= '<div class="biblio-year">' .$_year. "</div>\n";
       }
    } //end switch
    $content .= '<div class="biblio-entry">' . "\n";
    $inline_links = ($inline && variable_get('inlinemode_in_links',0)) ? true : false;
    $content .= theme('biblio_list', $node,$base,$style,$inline_links);
    $content .= "</div>\n";
  } //end while
  $content .= theme('pager', 0, variable_get('biblio_rowsperpage', 25));
  if (!db_num_rows($result)) {
    $content .= "<h3>".t("No items found")."</h3>";
    if (strstr($content, "Filters:")) {
      $content .= t('!modify_link or !remove_link your filters and try again.', array('!modify_link' => l(t('Modify'),"$base/filter"), '!remove_link' => l(t('remove'),"$base/filter/clear")));
    }
  }
  if (!$inline) {
    print theme('page', $content);
  }elseif ($inline == 'profile'){
    return $content ;
  }else{
    print $content . "</div>";
  }

}

function biblio_db_search() {
global $user;
$inline = false;
$join = array();
  $join[] = "left join {biblio} b  on n.vid=b.vid ";
  $join[] = "left join {biblio_types} bt  on b.biblio_type=bt.tid ";
   if (variable_get('biblio_view_only_own', 0) ) {
      $limit .= " AND n.uid=$user->uid ";
   }

  $pager_attrib = array("sort" => variable_get('biblio_sort', 'year'), 'order' => variable_get('biblio_order', 'DESC'));
  $limits = null;

  if (isset($_GET['order'])) {
    $pager_attrib['order'] = ($_GET['order'] == 'desc') ? 'desc' : 'asc';
  }
  if (isset($_GET['sort'])) {
    $pager_attrib['sort'] = check_plain($_GET['sort']);
  }

  switch ($pager_attrib['sort']) {
    case 'type':
      $sortby = "ORDER BY b.biblio_type %s, b.biblio_year DESC, SUBSTRING(n.title,1,1) ASC ";
      break;
    case 'title':
      $sortby = "ORDER BY SUBSTRING(n.title,1,1) %s, b.biblio_year DESC ";
      break;
    case 'author':
      /*$join[] = "inner join {biblio_has_author} as ha on a.aid = ha.aid";
      $join[] = "inner join  {biblio_author_index} as a on b.nid= ha.nid";
      $sortby = " ORDER BY a.author %s ";
      $where[] = "ha.rank = 1 ";
      */
      $sortby = "ORDER BY SUBSTRING(LTRIM(b.biblio_authors),1,1) %s, b.biblio_year DESC ";
      break;
    case 'keyword': // added msh 070808
      $sortby = "ORDER BY SUBSTRING(LTRIM(b.biblio_keywords),1,4) %s, b.biblio_keywords ASC ";
    break;
    case 'year':
    default:
      $sortby = "ORDER BY b.biblio_year %s, b.biblio_date DESC, SUBSTRING(n.title,1,1) ASC, b.biblio_type ASC ";
  } //end switch
  if (!isset($_SESSION['biblio_filter']) || !is_array($_SESSION['biblio_filter'])) {
    $_SESSION['biblio_filter'] = array();
  }

  $numargs = func_num_args();
  $arg_list = func_get_args();

  if (!in_array('profile',$arg_list)){ //don't include any stored filters on the profile page
    $session = &$_SESSION['biblio_filter'];
    foreach ($session as $filter) {
      $arg_list = array_merge($arg_list, $filter);
    }
  }

  if (count($arg_list) >= 1) {
    $args = array();
    while ($arg_list) {
      $type = $arg_list[0];
      array_shift($arg_list);
      $operator = ($operator)?$operator:" AND "; //defaults to AND
      switch ($type) {
        case 'and':
          $operator = " AND ";
          break;
        case 'or':
          $operator = " OR ";
          break;
        case 'inline':
          $inline = 'inline';
          break;
        case 'profile':
          $inline = "profile";
          break;
        case 'term':
        case 'term_id':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $join[] = "inner join {term_node} as tn on n.nid = tn.nid";
          if ($type == 'term') {
            $join[] = "inner join  {term_data} as td on tn.tid= td.tid";
            $where[] = "td.name = '%s' ";
          }elseif ($type == 'term_id') {
            $where[] = "tn.tid = '%d' ";
          }
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          break;
		case 'rss.xml':
		  $rss = TRUE;
		  break;
        case 'author':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $where[] = 'b.biblio_authors RLIKE "[[:<:]]%s[[:>:]]" ';
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          $title = 'Author - '.$term[0];
          $operator = NULL;
          break;
        case 'publisher':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_publisher RLIKE '%s' ";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          $operator = NULL;
          break;
        case 'year':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_year=%d ";
          //$limit .= " AND b.biblio_year=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          $operator = NULL;
          break;
        case 'uid':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $where[] = "n.uid=%d ";
          //$limit .= " AND b.biblio_year=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          $operator = NULL;
          break;
        case 'keyword':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_keywords RLIKE '%s' ";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          $operator = NULL;
          break;
        case 'type':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $limit .= $operator. "b.biblio_type=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          $operator = NULL;
          break;
        case 'order':
          $term = (db_escape_string($arg_list[0]) == 'desc')?'desc':'asc';
          array_shift($arg_list);
          $pager_attrib['order'] = $term;
          array_push($args, $type, $term);
          break;
        case 'sort':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $pager_attrib['sort'] = $term;
          array_push($args, $type, $term);
          switch ($term) {
            case 'type':
              $sortby = "ORDER BY b.biblio_type %s, b.biblio_year DESC, SUBSTRING(n.title,1,1) ASC ";
              break;
            case 'title':
              $sortby = "ORDER BY SUBSTRING(n.title,1,1) %s, b.biblio_year DESC ";
              break;
            case 'year':
            default:
              $sortby = "ORDER BY b.biblio_year %s, SUBSTRING(n.title,1,1) ASC, b.biblio_type ASC ";
          } //end switch
          break;
        default:
          $fields = biblio_get_db_fields();
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          if (in_array("biblio_$type",$fields))
          {
            $where[] = "b.biblio_$type RLIKE '%s' ";
            $terms[] = db_escape_string($term[0]);
            array_push($args, $type, $term[0]);
            $operator = NULL;
          }
          break;

      }
    }
  }
  $where[] = "n.type='biblio' ";
  if ($user->uid != 1 ) {
    $where[] = 'n.status = 1 ';
  }//show only published entries to everyone except admin

  $joins = implode(' ', $join);

  $where_clause = count($where) > 1 ? '('. implode(') AND (', $where) .')': $where[0];

  $query = db_rewrite_sql("SELECT DISTINCT n.*, b.*, bt.name as biblio_type_name FROM {node} n $joins  WHERE $where_clause $published $limit $sortby ");
  $count_query = db_rewrite_sql("SELECT DISTINCT COUNT(*) FROM {node} n $joins  WHERE $where_clause $published $limit ");
//echo $query; die;
  $_SESSION['last_biblio_query'] = $query;
  $terms[] = $pager_attrib['order'];
  $_SESSION['last_biblio_query_terms'] = $terms;

  $result = pager_query($query, variable_get('biblio_rowsperpage', 25),0,$count_query,$terms);
  if ($rss)
  {
  	biblio_feed($result, $title);
  }
  else
  {
    return biblio_show_results($result, $pager_attrib, $args,$inline);
  }
}

function _biblio_export($format="tagged", $nid = null, $version = 7) {
  $params=array();
  if ($nid === null && isset($_SESSION['last_biblio_query']) && !empty($_SESSION['last_biblio_query']) ) {
    $query = $_SESSION['last_biblio_query'];
    $params = $_SESSION['last_biblio_query_terms'];
  } elseif (!empty($nid)) {
    $query = db_rewrite_sql("SELECT * FROM {node} n left join {biblio} b  on n.vid=b.vid
                WHERE n.nid=%d ");
    $params[] = $nid;
  }else{
    return;
  }

  $result = db_query($query,$params);
  while ($node = db_fetch_object($result)) {
    $results[] = $node;
  }

  if (count($results)) {
     switch($format) {
     case "tagged":
       header('Content-type: 	application/x-endnote-refer');
       header('Content-Disposition:  filename="Drupal-Biblio.enw"');
       print _endnote_tagged_export($results);
       break;
     case "xml":
       header('Content-type: application/xml; charset=utf-8');
       header('Content-Disposition: attachment; filename="Biblio-EndNote'.$version.'.xml"');
       print _endnote_XML_export($results, $version );
       break;
     case "bib":
       header('Content-type: 	application/text charset=utf-8');
       header('Content-Disposition:  filename="Biblio-Bibtex.bib"');
       print _bibtex_export($results);
       break;
     }
  }
}

/**
 * Adapt date string to the necessary format
 * @param string $input the date string to adapt
 * @param string $to datefmt to return
 *        if null, then it returns the number
 * @return a SINGLE date (the first)
 */
function _biblio_date($input,$to=null) {
  $my_date = $input;
  ///strtotime defaults to assuming mm/dd/yy,
  /// so we need to pre-empt it for dd/mm/yyyy (legacy)
  $legacy_fmt = preg_match('|((\d+)/)?(\d+)/(\d+)|',$input,$matches);
  if ($legacy_fmt) {
    $my_date = $matches[4].'-'.$matches[3];
    $my_date .= ($matches[1] ? '-'.$matches[2] : '');
  } 
  $my_date = strtotime($my_date);
  if (!$my_date) {
    ///on strtotime error, fail back to the original
    return $input; 
  }
  return ($to ? date($to,$my_date): $my_date);
}

function _bibtex_export($results) {
    if (!is_array($results))
    {
      $result_array[] = $results;
    }else{
      $result_array = $results;
    }
  $bibtex = '';

  foreach ($result_array as $pub) {
    $type = "article";
    $journal = $series = $booktitle = $school = $organization = null;
    switch ($pub->biblio_type) {
      case 102:
        $type = "article";
        $journal = $pub->biblio_secondary_title;
       break;
      case 100:
        $type = "book";
        $series = $pub->biblio_secondary_title;
         break;
      case 101:
        $type = "inbook";
        $booktitle = $pub->biblio_secondary_title;
         break;
//      case 103:
//        $type = "conference";
//         break;
      case 100:
        $type = "incollection";
         break;
      case 103:
        $type = "inproceedings";
        $journal = $pub->biblio_secondary_title;
        $organization = $pub->biblio_publisher;
         break;
      case 129:
        $type = "misc";
         break;
      case 108:
        $type = "phdthesis";
        $school = $pub->biblio_publisher;
        $pub->biblio_publisher = null;
         break;
      case 104:
        $type = "proceedings";
         break;
      case 109:
        $type = "techreport";
        $institution = $pub->biblio_publisher;
        $pub->biblio_publisher = null;
         break;
      case 124:
        $type = "unpublished";
         break;
    }

    $bibtex .= '@'.$type.' { ';
    $bibtex .= ($pub->biblio_citekey)? $pub->biblio_citekey.",\n":",\n";
    if ($pub->title) $bibtex .= "\ttitle = {".$pub->title."},\n";
    if ($journal) $bibtex .= "\tjournal = {".$journal."},\n";
    if ($booktitle) $bibtex .= "\tbooktitle = {".$booktitle."},\n";
    if ($series) $bibtex .= "\tseries = {".$series."},\n";
    if ($pub->biblio_secondary_authors) $bibtex .= "\teditor = {".$pub->biblio_secondary_authors."},\n";
    if ($pub->biblio_volume) $bibtex .= "\tvolume = {".$pub->biblio_volume."},\n";
    if ($pub->biblio_number) $bibtex .= "\tnumber = {".$pub->biblio_number."},\n";
    if ($pub->biblio_year) $bibtex .= "\tyear = {".$pub->biblio_year."},\n";
    if ($pub->biblio_notes) $bibtex .= "\tnote = {".$pub->biblio_notes."},\n";
    if ($pub->biblio_date) $bibtex .= "\tmonth = {".$pub->biblio_date."},\n";
    if ($pub->biblio_pages) $bibtex .= "\tpages = {".$pub->biblio_pages."},\n";
    if ($pub->biblio_publisher) $bibtex .= "\tpublisher = {".$pub->biblio_publisher."},\n";
    if ($school) $bibtex .= "\tschool = {".$school."},\n";
    if ($organization) $bibtex .= "\torganization = {".$organization."},\n";
    if ($institution) $bibtex .= "\tinstitution = {".$institution."},\n";
    if ($pub->biblio_type_of_work) $bibtex .= "\ttype = {".$pub->biblio_type_of_work."},\n";
    if ($pub->biblio_edition) $bibtex .= "\tedition = {".$pub->biblio_edition."},\n";
    if ($pub->biblio_section) $bibtex .= "\tchapter = {".$pub->biblio_section."},\n";
    if ($pub->biblio_place_published) $bibtex .= "\taddress = {".$pub->biblio_place_published."},\n";
    if ($pub->biblio_abst_e) $bibtex .= "\tabstract = {".$pub->biblio_abst_e."},\n";
    if ($pub->biblio_keywords) $bibtex .= "\tkeywords = {".$pub->biblio_keywords."},\n";
    if ($pub->biblio_isbn) $bibtex .= "\tISBN = {".$pub->biblio_isbn."},\n";
    if ($pub->biblio_url) $bibtex .= "\tURL = {".$pub->biblio_url."},\n";
    $author =  str_replace("; ", " and ", $pub->biblio_authors);
    $bibtex .= "\tauthor = {".$author."}\n";

    $bibtex.="}\n\n";

  }

  return $bibtex;

}
function _endnote_XML_export($results, $version = 7) {

   if ($version == 8) {
      require_once(drupal_get_path('module', 'biblio') . '/endnote8_export.inc');
     $xml = _endnote8_XML_export($result);
    }elseif ($version == 7) {
      require_once(drupal_get_path('module', 'biblio') . '/endnote7_export.inc');
     $xml = _endnote7_XML_export($results);
    }
    return $xml;
}

function _endnote_tagged_export($results) {
    if (!is_array($results))
    {
      $result_array[] = $results;
    }else{
      $result_array = $results;
    }
    $doc = "";
    foreach ($result_array as $pub ) {
      switch ($pub->biblio_type) {
        case 6:
        case 100:
          $doc .= "%0 Book\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // book section
        case 101:
          $doc .= "%0 Book Section\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // book section
        case 1:
        case 102: $doc .= "%0 Journal Article\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%J " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // journal
        case 2:
        case 103: $doc .= "%0 Conference Paper\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break;
        case 3: // are all
        case 104: $doc .= "%0 Conference Proceedings\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // conference proceedings
        case 105: $doc .= "%0  Newspaper Article\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break;
        case 107: $doc .= "%0  Web Page\r\n";
          break;
        case 108:
          $doc .= "%0 Thesis\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // thesis
        case 5:
        case 109:
          $doc .= "%0 Report\r\n";
          break; // report
        case 110:
        case 111:
          $doc .= "%0  Film or Broadcast\r\n";
          break;
        case 112:
          $doc .= "%0  Artwork\r\n";
          break;
        case 114:
          $doc .= "%0  Audiovisual Material\r\n";
          break;
        case 115:
          $doc .= "%0  Hearing\r\n";
          break;
        case 116:
          $doc .= "%0  Case\r\n";
          break;
        case 117:
          $doc .= "%0  Bill\r\n";
          break;
        case 118:
          $doc .= "%0  Statute\r\n";
          break;
        case 119:
          $doc .= "%0  Patent\r\n";
          break;
        case 120:
          $doc .= "%0  Personal Communication\r\n";
          break;
        case 121:
          $doc .= "%0  Manuscript\r\n";
          break;
        case 122:
          $doc .= "%0  Map\r\n";
          break;
        case 123:
          $doc .= "%0  Chart or Table\r\n";
          break;
        case 124:
          $doc .= "%0  Unpublished Work\r\n";
          break;
        case 125:
          $doc .= "%0  Online Database\r\n";
          break;
        case 126:
          $doc .= "%0  Government Document\r\n";
          break;
        case 127:
          $doc .= "%0  Classical Work\r\n";
          break;
        case 128:
          $doc .= "%0  Legal Rule or Regulation\r\n";
          break;
        case 7:
        case 8:
        case 119:
          $doc .= "%0 Patent\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // patent
        case 9:
        default:
          $doc .= "%0 Generic\r\n";
          break; // generic
      }
      $doc .= "%D " . trim($pub->biblio_year) . "\r\n";
      $doc .= "%T " . trim($pub->title) . "\r\n";

      $author_array = _parse_author_array(explode(';', $pub->biblio_authors));
      foreach($author_array as $auth) {
        $doc .= "%A " . $auth['last_name'] . ($auth['first_name'] ? (', ' . $auth['first_name']) : ($auth['initials'] ? (', ' . $auth['initials']) : '')) . "\r\n";
      }

      if ($pub->biblio_place_published) $doc .= "%C " . trim($pub->biblio_place_published) . "\r\n";
      if ($pub->biblio_secondary_authors) {
        $author_array = explode(";", $pub->biblio_secondary_authors);
        foreach($author_array as $auth) {
          $doc .= "%E " . trim($auth) . "\r\n";
        }
      }
      if ($pub->biblio_publisher) $doc .= "%I " . trim($pub->biblio_publisher) . "\r\n";
      if (trim($pub->biblio_keywords)) $doc .= "%K " . trim($pub->biblio_keywords) . "\r\n";
      if ($pub->biblio_call_number) $doc .= "%L " . trim($pub->biblio_call_number) . "\r\n";
      if ($pub->biblio_accession_number) $doc .= "%M " . trim($pub->biblio_accession_number) . "\r\n";
      if ($pub->biblio_issue) $doc .= "%N " . trim($pub->biblio_issue) . "\r\n";
      if ($pub->biblio_pages) $doc .= "%P " . trim($pub->biblio_pages) . "\r\n";
      if ($pub->biblio_tertiary_title) $doc .= "%S " . trim($pub->biblio_tertiary_title) . "\r\n";
      if ($pub->biblio_url) $doc .= "%U " . trim($pub->biblio_url) . "\r\n";
      if ($pub->biblio_volume) $doc .= "%V " . trim($pub->biblio_volume) . "\r\n";
      $abst = "";
      if ($pub->biblio_abst_e) $abst .= trim($pub->biblio_abst_e);
      if ($pub->biblio_abst_f) $abst .= trim($pub->biblio_abst_f);
      if ($abst) {
        $search = array("/\r/", "/\n/");
        $replace = " ";
        $abst = preg_replace($search, $replace, $abst);
        $doc .= "%X " . $abst . "\r\n";
      }
      if ($pub->biblio_tertiary_authors) {
        $author_array = explode(";", $pub->biblio_tertiary_authors);
        foreach($author_array as $auth) {
          $doc .= "%Y " . trim($auth) . "\r\n";
        }
      }
      if ($pub->biblio_notes) $doc .= "%Z " . trim($pub->biblio_notes) . "\r\n";
      if ($pub->biblio_edition) $doc .= "%7 " . trim($pub->biblio_edition) . "\r\n";
      if ($pub->biblio_date) $doc .= "%8 " . trim($pub->biblio_date) . "\r\n";
      if ($pub->biblio_type_of_work) $doc .= "%9 " . trim($pub->biblio_type_of_work) . "\r\n";
      if ($pub->biblio_isbn) $doc .= "%@ " . trim($pub->biblio_isbn) . "\r\n";

      $doc .= "\r\n";
    }

  return $doc;
}

function _biblio_admin_build_user_select($my_uid) {
  $sql = 'SELECT DISTINCT u.uid, u.name, u.status, u.mail FROM {users} u  WHERE u.uid != 0 ';
  $result = db_query($sql);
  while ($user = db_fetch_object($result)) {
      $users[$user->uid] = $user->name ." ($user->mail)";
  }
  asort($users);
  $select = array(
    '#type' => 'select',
    '#title' => t("Set user ID of entries in this file to"),
    '#options' => $users,
    '#default_value' => $my_uid
  );
  return $select;
}

function biblio_form_import() {
global $user;

  if (biblio_access('import')) { // && !user_access('administer nodes')) {

      $form['#attributes']['enctype'] = 'multipart/form-data';
      $form["file_upload"] = array(
        '#type' => 'file',
        '#title' => t('Import file'),
        '#default_value' => '',
        '#size' => 60,
      );
      $form['filetype'] = array(
        '#type' => 'radios',
        '#title' => t('File Type'),
        '#default_value' => '',
        '#options' => array('tagged' => t('EndNote Tagged'),'ris' => t('RIS') , 'xml'=>t('EndNote 7 XML'), 'xml8'=>t('EndNote 8+ XML'), 'bib'=>t('BibTex')),
      );
      if ($user->uid) {
        $form{'userid'} =  _biblio_admin_build_user_select($user->uid);
      }
   // Get the vocabularies  attached to the biblio node type ...
      $vocabularies = module_invoke('taxonomy', 'get_vocabularies', 'biblio');

      // ... and print a form to select the terms in each of them
      $form['import_taxonomy'] = array(
        '#type' => 'fieldset',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#title' => t('Taxonomy Settings'),
        '#description' => t('Here you may select terms to be assigned to imported records (if any vocabularies are assigned to the biblio node type)'),
      );

      if (count($vocabularies)) {
        $i=0;
        foreach ($vocabularies as $vocabulary) {
          $form['import_taxonomy']['vocabulary'.$i] = module_invoke('taxonomy', 'form', $vocabulary->vid, 0);
          $form['import_taxonomy']['vocabulary'.$i++]['#description'] = t("Select taxonomy term to assigned to imported entries");
        }
      }else{
        $vocab_msg = t('There are currently no vocabularies assigned to the biblio node type, please go the the !url page to fix this', array('!url'=> l(t('admin/content/taxonomy'),'admin/content/taxonomy')));
        $form['import_taxonomy']['vocabulary_message'] = array('#value' => '<p><div>'.$vocab_msg.'</div></p>');
      }

      if (variable_get('biblio_keyword_freetagging', 0)) {
        $freetag_vocab = module_invoke('taxonomy', 'get_vocabulary', variable_get('biblio_freetagging_vocab', 0));
        $msg = t('Keywords will be added to the <b>@name</b> vocabulary as specified in the Taxonomy section of the !url page.', array('@name'=> $freetag_vocab->name, '!url' => l(t('admin/settings/biblio'),'admin/settings/biblio')));
      }else{
        $msg = t('Keywords will <b>NOT</b> be added to the vocabulary as specified in the Taxonomy section of the !url page.', array('!url' => l(t('admin/settings/biblio'),'admin/settings/biblio')));
      }
      $form['import_taxonomy']['freetagging_information'] = array('#value' => '<p><div>'.$msg.'</div></p>');


      $form['button'] = array(
        '#type' => 'submit',
        '#value' => t('Import')
      );

      return $form;
      //print theme('page', form($form, 'post', null, $attributes));

  } else {
    drupal_set_message("You are not authorized to access the biblio import page", 'error');

    print theme('page', '');
  }
}
function biblio_form_import_validate($form_id, $form_values) {

    $op = $form_values['op'];
    $filetype = $form_values['filetype'];
    $edit = $_POST;
    if (!file_check_upload('file_upload')) {
        form_set_error('',t("You must provide a file name"));
    }
    if ($op == t('Import') && $filetype == '') {
       form_set_error('',t("You must select a file type"));
    }

}
function biblio_form_import_submit($form_id, $form_values) {
  $op = $form_values['op'];
    if ($form_values['op'] == t('Import') && isset($form_values['filetype'])) {
      $import = file_check_upload('file_upload');
      if ($import) {
        $import = file_save_upload($import);
        drupal_set_message(t("@file was uploaded", array('@file' => $import->filename)), 'status');

        // Concatenate all the terms of the different vocabularies
        // in a single array to be sent to _biblio_import
        $terms = array();
        foreach (array_keys($form_values) as $key) {
          if (preg_match('/(vocabulary[0-9]+)/', $key)) {
            if ($form_values[$key] > 0) $terms[] = $form_values[$key];
          }
        }
        // Added the $terms argument
        // the array of terms to be attached to the node(s)
        $userid = (isset($form_values['userid']))? $form_values['userid'] : 1;
        $filetype = $form_values['filetype'];
        $content = _biblio_import($userid, $import->filepath, $filetype, $terms);
        file_delete($import->filepath);

      } else {
        drupal_set_message(t("File was NOT successfully uploaded"), 'error');
      }
  }
}

function _biblio_import($userid = 1, $filename = null, $type = 'tagged', $terms = null) {
  global $user;
  $node = array();
  $node_ids = "";

  if (file_exists($filename)) {
    if (($file_content = @file_get_contents($filename)) === false) {
        return false;
    } else {
      $options = variable_get('node_options_biblio',array('status'));
      if (module_exists('i18n') && variable_get('i18n_node_biblio',0)){
        $node['language'] = module_invoke('i18n','default_language');
      }
      $node['type']     = "biblio";
      $node['created']  = time();
      $node['changed']  = time();
      $node['comment']  = variable_get('comment_biblio',0);
      $node['promote']  = in_array('promote',$options);
      $node['moderate'] = in_array('moderate',$options);
      $node['sticky']   = in_array('sticky',$options);
      $node['format']   = 0;
      $node['status']   = in_array('status',$options);
      $node['uid']      = $userid;
      switch($type) {
      case 'tagged': // EndNote Tagged
        require_once(drupal_get_path('module', 'biblio') . '/tagged_parser.inc');
        $node_ids  = _endnote_tagged_import($file_content,$node);
        break;
      case 'xml': // EndNote 7 XML
       $node_ids  = _endnote_XML_import($file_content ,$node, 7 );
      break;
      case 'xml8': // EndNote 8+ XML
       $node_ids  = _endnote_XML_import($file_content ,$node, 8 );
        break;
      case 'bib': // BibTex
       $node_ids  = _bibtex_import($file_content ,$node );
        break;
      case 'ris': // RIS
        require_once(drupal_get_path('module', 'biblio') . '/ris_parser.inc');
        $node_ids  = _ris_tagged_import($file_content,$node);
        break;
     }
     if ($terms && count($node_ids)) {
    	  // set the vocabulary for the returned nodes
    	  foreach ($node_ids as $node_id) {
    		  module_invoke('taxonomy', 'node_save', $node_id,  $terms);
    	  }
     }
     if (count($node_ids)){
       db_query('UPDATE {node} SET uid = %d WHERE nid IN(%s)', $userid, implode(',', $node_ids));
       db_query('UPDATE {node_revisions} SET uid = %d WHERE nid IN(%s)', $userid, implode(',', $node_ids));

     }
      return $node_ids;
    }
  } else {
    return false;
  }
}

function _endnote_XML_import(&$data ,$nodedata, $version = 8) {
global $user,$records, $rec_count,$node_array,$node,$node_id;
  $node_array = array();
  $node = $nodedata;
  $xml_parser = drupal_xml_parser_create($data);

// use case-folding so we are sure to find the tag in
  xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, false);
  xml_parser_set_option($xml_parser, XML_OPTION_SKIP_WHITE, true);
  if ($version == 8) {
    require_once(drupal_get_path('module', 'biblio') . '/endnote8_parser.inc');
    xml_set_element_handler($xml_parser, "en8_startElement", "en8_endElement");
    xml_set_character_data_handler($xml_parser, "en8_characterData");
    xml_parse($xml_parser, $data,1);
  }elseif ($version == 7) {
    require_once(drupal_get_path('module', 'biblio') . '/endnote7_parser.inc');

    xml_parse_into_struct($xml_parser, $data, $values);

    en7_parse($values,$node_array,$node) ;

  }

  xml_parser_free($xml_parser);

  $node_ids = _biblio_save_imported_nodes($node_array);

  return ($node_ids);
}

function _bibtex_import(&$data, $node) {
require_once(drupal_get_path('module', 'biblio') . '/bibtexParse/PARSEENTRIES.php');

  $node_array = array();

 // $bibtex = new Structures_BibTex();
 // $bibtex->loadString($data);
  $bibtex = new PARSEENTRIES();
  $bibtex->loadBibtexString($data);
  $bibtex->extractEntries();
  if ($bibtex->count) {
    $bibtex->bib2node($node_array, $node);
    $node_ids = _biblio_save_imported_nodes($node_array);
  }
  return $node_ids;
}

function _biblio_save_imported_nodes(&$node_array) {

  if (function_exists('node_save')) {
    foreach ($node_array as $node) {
      $node = (object)$node;
      if (variable_get('biblio_keyword_freetagging',0) && variable_get('biblio_freetagging_vocab',0)) {
        $vid = variable_get('biblio_freetagging_vocab',0);
        $node->taxonomy['tags'][$vid] = str_replace(';',',',$node->biblio_keywords);
      }
      node_save($node);
      if ($node->nid) {
         $node_ids[] = $node->nid;
      }
    }
  }
  drupal_set_message(t("Succesfully imported @count entries.", array('@count' => count($node_ids))), 'status');

  return $node_ids;
}

function biblio_get_db_fields() {
  $fields = array();
  $fields[] = 'nid';
  $fields[] = 'vid';
  $fields[] = 'biblio_type';
  $result = db_query('SELECT name FROM {biblio_fields} ');
  while ($field = db_fetch_array($result)) {
    $fields[] = $field['name'];
  }
  return $fields ;
}
function _biblio_author_links($author,$base='biblio',$inline=false) {
  $query = null;
  $inline = $inline ? "/inline" : "";
  //$attrib = (variable_get('biblio_links_target_new_window',null)) ? array('target'=>'_blank') : null;
  $attrib = null;

  if (isset($_GET['sort'])) {
    $query  .= "sort=" . $_GET['sort'];
  }
  if (isset($_GET['order'])) {
    $query  .= $query ?"&":"";
    $query  .= "order=" . $_GET['order'];
  }

  $html = "";
  $etal = '';
  if (strpos($author, 'et al.')) {
    $author = str_replace('et al.', "", $author);
    $etal = 'et al.';
  }

  $author_array = explode(";", $author);

  foreach($author_array as $auth) {
    $html .= (empty($html))? "" : "; ";
    if (strstr($auth, ",")) {
      $parts = split(",", $auth);
      $lastname = $parts[0];
    } else {
      $parts = split(" ", $auth);
      $lastname = end($parts);
    }
    // list($lastname, $init) = split(",", $auth);

    $html .= l(trim($auth), "$base/author/" . trim($lastname) . $inline,$attrib, $query );
  }
  return $html." $etal";
}
function _biblio_single_author_link($author, $base='biblio', $inline=false) {
  $query = null;
  $inline = $inline ? "/inline" : "";
  //$attrib = (variable_get('biblio_links_target_new_window',null)) ? array('target'=>'_blank') : null;
  $attrib = null;

  if (isset($_GET['sort'])) {
    $query  .= "sort=" . $_GET['sort'];
  }
  if (isset($_GET['order'])) {
    $query  .= $query ?"&":"";
    $query  .= "order=" . $_GET['order'];
  }

  $html = "";

  $html .= (empty($html))? "" : "; ";
    if (strstr($author, ",")) {
      $parts = split(",", $author);
      $lastname = $parts[0];
    } else {
      $parts = split(" ", $author);
      $lastname = end($parts);
    }
    // list($lastname, $init) = split(",", $auth);

    $html .= l(trim($author), "$base/author/" . trim($lastname) . $inline,$attrib, $query );

  return $html;
}
function biblio_author_index_shutdown() {
  global  $biblio_last_nid;

  if ($biblio_last_nid) {
    variable_set('biblio_ai_last_nid', $biblio_last_nid);
  }

}
function biblio_update_author_index() {
  global  $biblio_last_nid;

  //register_shutdown_function('biblio_author_index_shutdown');
  $biblio_last_nid = variable_get('biblio_ai_last_nid', 0);
  $biblio_max_count = variable_get('biblio_ai_max_count', 100);
  $count = 0;
  $result  = db_query("SELECT nid, biblio_authors FROM {biblio} WHERE nid > %d",$biblio_last_nid);
  while ( ($row = db_fetch_object($result)) && ($count < $biblio_max_count) ) {
    $author_array = explode(";", $row->biblio_authors);
    $rank = 0;
    foreach($author_array as $auth) {
      $rank++;
      if (strstr($auth, ",")) {
        $parts = split(",", $auth);
        $lastname = $parts[0];
      } else {
        $parts = split(" ", $auth);
        $lastname = end($parts);
      }
      _biblio_author_index_insert($row->nid, $lastname,$rank);
      $biblio_last_nid = $row->nid;
    }
    $count++;
  }
    variable_set('biblio_ai_last_nid', $biblio_last_nid);

  return ;
}

function _biblio_author_index_insert($nid, $author,$rank) {
  $uc_author = trim(drupal_strtoupper($author));
  $result = db_query("SELECT * FROM {biblio_author_index} WHERE author = '%s'",$uc_author);
  $author_exist = db_num_rows($result);

  if ($author_exist) {
    $row = db_fetch_object($result);
    $result = db_query("INSERT INTO {biblio_has_author} (`nid`,`aid`,`rank`) VALUES (%d,%d,%d)",$nid,$row->aid,$rank);
  }else{
    $aid = db_next_id('{biblio_author_index}_aid');
    $result = db_query("INSERT INTO {biblio_author_index} (`aid`,`author`) VALUES (%d,'%s')",$aid,$uc_author);
    $result = db_query("INSERT INTO {biblio_has_author} (`nid`,`aid`,`rank`) VALUES (%d, %d, %d)",$nid,$aid,$rank);

  }
  return ;
}



function _biblio_keyword_links($keywords,$base='biblio') {
  if (isset($_GET['sort'])) {
    $query  .= "sort=" . $_GET['sort'];
  }
  if (isset($_GET['order'])) {
    $query  .= $query ?"&":"";
    $query  .= "order=" . $_GET['order'];
  }

  $html = "";
  $sep = variable_get('biblio_keyword_sep', ',');
//  if (strstr($keywords,';')) {
    $keyword_array = explode($sep, $keywords);
/*  }elseif (strstr($keywords,',')) {
    $keyword_array = explode(",", $keywords);
  }else{
    $keyword_array = explode(" ", $keywords);
  }
*/
  foreach($keyword_array as $kw) {
    $html .= (empty($html))? "" : "; ";
    $html .= l(trim($kw), "$base/keyword/" . trim($kw), NULL, $query);
  }
  return $html;
}

function _biblio_parse_authors($authors) {
$and = array(" and ", " And ", " AND ");
$etal = "";
$author_array = array();
if (strpos($authors, 'et al')) {
  if (strpos($authors, 'et al.')) {
    $authors = str_replace('et al.', "", $authors);
  }else{
    $authors = str_replace('et al', "", $authors);
  }
  $etal = 'et al.';
}
$authors = str_replace($and, "; ", $authors); // change the word "and" to a comma
$authors = str_replace(" ,", ",", $authors); // fix some potential typos
$authors = str_replace(",,", ",", $authors); // ditto
// $authors = str_replace(";",",",$authors);
$chunks = explode(";", $authors); // split the authors on the semicolon
$num_chunks = count($chunks);

  foreach ($chunks as $chunk) {
    if (strlen(trim($chunk))){
    $suffix = _biblio_get_suffix($chunk); // get and strip out the suffix
    $prefix = _biblio_get_prefix($chunk); // get and strip out the prefix
    if (strstr($chunk, ",")) { // we probably have lastname first
      $subchunks = explode(",", trim($chunk));
      $lastname = $subchunks[0];
      $subchunks = explode(" ", trim($subchunks[1]));
      $initials = "";
      for ($j = 0; $j < count($subchunks) ;  $j++) {
        if (substr_count($subchunks[$j], '.')) {
          $initials .= $subchunks[$j];
        } else {
          $initials .= drupal_substr($subchunks[$j], 0, 1) . ".";
        }
      }
    } else { // we have some form of firstname first (Fistname I. Lastname)
      $subchunks = explode(" ", trim($chunk));
      $lastname = end($subchunks);
      $initials = "";
      for ($j = 0;
        $j < count($subchunks) - 1 ;
        $j++) {
        if (substr_count($subchunks[$j], '.')) {
          $initials .= $subchunks[$j];
        } else {
          $initials .= drupal_substr($subchunks[$j], 0, 1) . ".";
        }
      }
    }
    $author_array[] = trim($prefix . $lastname . ', ' . $initials . ' ' . $suffix);
   }
  }

  return implode("; ", $author_array)." $etal";
}

function _biblio_get_suffix(&$name) {
$suffix = null;
  if (preg_match("/(.*[^, \.])[, \.]+(Jr|Sr|Snr|I|II|III|IV)\.?\s*$/", $name, $match)) {
    $name = $match[1];
    $suffix = $match[2];
  }

return $suffix;
}
function _biblio_get_prefix(&$name) {
  $prefix = null;
  $name = " " . $name;
  $prefs = array(" Van ", " van ", " von ", " den ", " der ", " de ", " De ", " ter ", " Ter ", "Vander ");
  if (strstr($name, " Van ")) $prefix .= "Van ";
  if (strstr($name, " van ")) $prefix .= "van ";
  if (strstr($name, " Vander ")) $prefix .= "Vander ";
  if (strstr($name, " von ")) $prefix .= "von ";
  if (strstr($name, " de ")) $prefix .= "de ";
  if (strstr($name, " De ")) $prefix .= "De ";
  if (strstr($name, " den ")) $prefix .= "den ";
  if (strstr($name, " der ")) $prefix .= "der ";
  if (strstr($name, " ter ")) $prefix .= "ter ";
  if (strstr($name, " Ter ")) $prefix .= "Ter ";
  if (strlen($prefix)) $name = str_replace($prefs, " ", $name);
  $name = trim($name);
  return $prefix;
}

function author_test() {
    $result  = db_query("SELECT nid, biblio_authors FROM {biblio} ");
    $carray = array();
    while ($row = db_fetch_object($result)) {
    //    $carray = explode(";",$authors->biblio_authors);
      //  $creators = _parse_author_array($carray);
      _biblio_author_index($row->nid,$row->biblio_authors);
      // echo $authors->nid;

    }
    $creators = _parse_author_array($carray);
}
function _parse_author_array($authorArray)
{
//	$input = trim($input);
// split on ' and '
//	$authorArray = preg_split("/\s(and)\s/i", $input);
// check if there's anything that looks like et. al
  $count=1;
	foreach($authorArray as $value)
	{
		$appellation = $prefix = $surname = $firstname = $initials = '';
		$author = explode(",", preg_replace("/\s{2,}/", ' ', trim($value)));
		$size = sizeof($author);
// No commas therefore something like Mark Grimshaw, Mark Nicholas Grimshaw, M N Grimshaw, Mark N. Grimshaw
		if ($size == 1)
		{
			$author = split(" ", $value);
// last of array is surname (no prefix if entered correctly)
			$surname = array_pop($author);
		}
// Something like Grimshaw, Mark or Grimshaw, Mark Nicholas  or Grimshaw, M N or Grimshaw, Mark N.
		else if ($size == 2)
		{
// first of array is surname (perhaps with prefix)
			list($surname, $prefix) = _grabSurname(array_shift($author));
		}
// If $size is > 2, we're looking at something like Bush, George W, III
		else
		{
// last of array is 'Jr.', 'IV' etc.
			$appellation = array_pop($author);
// first of array is surname (perhaps with prefix)
			list($surname, $prefix) = _grabSurname(array_shift($author));
		}
		$remainder = join(" ", $author);
		list($firstname, $initials) = _grabFirstnameInitials($remainder);
		$surname = $surname . ' ' . $appellation;
		$creators[] = array('first_name'=> trim("$firstname"),
                        'initials'  => trim("$initials"),
                        'last_name' => trim("$surname"),
                        'prefix'    => trim("$prefix"),
                        'order'     => "$count");
    $count++;
	}
	if (isset($creators))
		return $creators;
	return FALSE;
}
// grab firstname and initials which may be of form "A.B.C." or "A. B. C. " or " A B C " etc.
function _grabFirstnameInitials($remainder)
{
	$firstname = $initials = '';
	$array = split(" ", $remainder);
	foreach($array as $value)
	{
		if (preg_match("/[a-zA-Z]{2,}/", trim($value)))
			$firstnameArray[] = trim($value);
		else
			$initialsArray[] = str_replace(".", " ", trim($value));
	}
	if (isset($initialsArray))
	{
		foreach($initialsArray as $initial)
			$initials .= ' ' . trim($initial);
	}
	if (isset($firstnameArray))
		$firstname = join(" ", $firstnameArray);
	return array($firstname, $initials);
}
// surname may have title such as 'den', 'von', 'de la' etc. - characterised by first character lowercased
function _grabSurname($input)
{
	$surnameArray = split(" ", $input);
	foreach($surnameArray as $value)
	{
		$firstChar = substr($value, 0, 1);
		if ((ord($firstChar) >= 97) && (ord($firstChar) <= 122))
			$prefix[] = $value;
		else
			$surname[] = $value;
	}
	if (isset($surname)) $surname = join(" ", $surname);
	if (isset($prefix))
	{
		$prefix = join(" ", $prefix);
		return array($surname, $prefix);
	}
	return array($surname, FALSE);
}

function biblio_views_tables() {

  $table = views_new_table('biblio', 'internal', 'node', 'vid', 'vid');
  $result = db_query('SELECT name,title FROM {biblio_fields} ');
  while ($field = db_fetch_array($result)) {
    views_table_add_field($table, $field['name'], "Biblio: ".$field['title'], "", array(
      'sortable' => true,
      'notafield' => false,
    ));
  }

  $tables['biblio'] = $table;
  $table = views_new_table('biblio_types', 'internal', 'biblio', 'tid', 'tid');
  $tables['biblio_types'] = $table;
  return $tables;
}
function biblio_views_default_views() {
  $view = new stdClass();
  $view->name = 'biblioview';
  $view->description = 'Shows a summary view of biblio entries';
  $view->access = array ();
  $view->view_args_php = '';
  $view->page = TRUE;
  $view->page_title = 'Biblio';
  $view->page_header = '';
  $view->page_header_format = '1';
  $view->page_footer = '';
  $view->page_footer_format = '1';
  $view->page_empty = '';
  $view->page_empty_format = '1';
  $view->page_type = 'table';
  $view->url = 'biblioview';
  $view->use_pager = TRUE;
  $view->nodes_per_page = '10';
  $view->sort = array ();
  $view->argument = array (
    array (
      'type' => 'nodetype',
      'argdefault' => '2',
      'title' => '',
      'options' => '',
      'wildcard' => 'biblio',
      'wildcard_substitution' => '',
    ),
  );
  $view->field = array (
    array (
      'tablename' => 'biblio',
      'field' => 'biblio_year',
      'label' => 'Year',
      'sortable' => '1',
      'defaultsort' => 'DESC',
    ),
    array (
      'tablename' => 'biblio',
      'field' => 'biblio_authors',
      'sortable' => '1',
      'label' => 'Author',
    ),
    array (
      'tablename' => 'node',
      'field' => 'title',
      'label' => 'Title',
      'handler' => 'views_handler_field_nodelink',
       'sortable' => '1',
     'options' => 'link',
    ),
  );
  $view->filter = array ();
  $view->exposed_filter = array ();
  $view->requires = array(biblio, node);
  $views[$view->name] = $view;
  return $views;
}

function biblio_nodeapi($node, $op) {
  switch ($op) {
  case 'delete revision':
      db_query('DELETE FROM {biblio} WHERE vid = %d', $node->vid);
      break;

  }

}

 /*******************************************
  * Filter
  * Largely inspired from the footnote module
  *
 *******************************************/

function _biblio_citekey_print($citekey) {
   $nid = db_fetch_object(db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = '%s' ORDER BY vid DESC", $citekey));
   if ($nid->nid > 0) {
     $style = variable_get('biblio_style', 'classic');
     $base =  variable_get('biblio_base', 'biblio');
     $node = node_load($nid->nid);
     return theme('biblio_short', $node, $base, $style);
   } else {
     return t("Citekey @cite not found", array('@cite' => $citekey));
   }

}


 /**
  * Implementation of hook_filter_tips().
  *
  * This hook allows filters to provide help text to users during the content
  * editing process. Short tips are provided on the content editing screen, while
  * long tips are provided on a separate linked page. Short tips are optional,
  * but long tips are highly recommended.
  */
function biblio_filter_tips($delta, $format, $long = FALSE) {
   switch ($delta) {
     case 0:
       if ($long) {
         return t('You can cite references directly into texts with <code>&lt;bib&gt;citekey&lt;/bib&gt;</code>. This will be replaced with a running number (the publication reference) and the publication referenced by the citekey within the &lt;bib&gt; tags will be print to the bottom of the page (the reference).');
       }
       else {
         return t('Use &lt;bib&gt;...&lt;/bib&gt; to insert automatically numbered references.');
       }
       break;
   }
}

 /**
  * Implementation of hook_filter().
  *
  * The bulk of filtering work is done here. This hook is quite complicated, so
  * we'll discuss each operation it defines.
  */
function biblio_filter($op, $delta = 0, $format = -1, $text = '') {
   // The "list" operation provides the module an opportunity to declare both how
   // many filters it defines and a human-readable name for each filter. Note that
   // the returned name should be passed through t() for translation.
   if ($op == 'list') {
     return array(
       0 => t('References &lt;bib&gt;'),
     );
   }
   if ($op == 'no cache') { return true; }

   // All operations besides "list" provide a $delta argument so we know which
   // filter they refer to. We'll switch on that argument now so that we can
   // discuss each filter in turn.
   switch ($delta) {

     // First is the html footnotes filter
     case 0:

       switch ($op) {
         // This description is shown in the administrative interface, unlike the
         // filter tips which are shown in the content editing interface.
         case 'description':
           return t('Use &lt;bib&gt;...&lt;/bib&gt; to insert automatically numbered references.');

         // We don't need the "prepare" operation for this filter, but it's required
         // to at least return the input text as-is.
         //TODO: May need to escape <fn> if we use HTML filter too, but Footnotes could be first
         case 'prepare':
           return $text;

         // The actual filtering is performed here. The supplied text should be
         // returned, once any necessary substitutions have taken place.
         case 'process':
          if (variable_get('biblio_footnotes_integration', 0) && module_exists('footnotes'))
          {  // this is used with footnote module integration to replace the <bib> tags with <fn> tags
             $text = preg_replace_callback('|<bib>(.*?)</bib>|s', '_biblio_filter_footnote_callback', $text);
             return $text;
          }else{
             $text = preg_replace_callback('|<bib>(.*?)</bib>|s', '_biblio_filter_replace_callback', $text);

             //Replace tag <footnotes> with the list of footnotes.
             //If tag is not present, by default add the footnotes at the end.
             //Thanks to acp on drupal.org for this idea. see http://drupal.org/node/87226
             $footer = '';
             $footer = _biblio_filter_replace_callback(NULL, 'output footer');
             if ( preg_match( '/<bibliography(\/( )?)?>/', $text ) > 0 ) {
               $text = preg_replace('/<bibliography(\/( )?)?>/', $footer, $text, 1);
               return $text;
             }
             else {
               return $text . "\n\n" . $footer;
             }
          }
       }
       break;
   }
}

function _biblio_filter_footnote_callback( $matches ) {

  $text = '<fn>' . _biblio_citekey_print($matches[1]) . "</fn>";

  return $text;

}

 /**
  * Helper function called from preg_replace_callback() above
  *
  * Uses static vars to temporarily store footnotes found.
  * In my understanding, this is not threadsafe?!
  */
function _biblio_filter_replace_callback( $matches, $op = '' ) {
   static $n = 0;
   static $store_matches = array();
   $str = '';

   if ( $op == 'output footer' ) {
     theme('biblio_add_css');
     if ( $n > 0 ) {
       $str = '<p><hr /><p><h3>'.t('References').'</h3></p>';
       $str .= '<div class="references"><ol>';
       for( $m = 1; $m <= $n; $m++ ) {
         $str .= '<li id="reference' . $m . '">' . _biblio_citekey_print($store_matches[ $m - 1 ]) . " </li>\n\n";
       }
       $str .= '</ol></div>';
     }
     $n = 0;
     $store_matches = array();
     return $str;
   }

   //default op: act as called by preg_replace_callback()
   array_push( $store_matches, $matches[1] );
   $n++;
   $allowed_tags = array();
   $title = filter_xss($matches[1], $allowed_tags);
   //html attribute cannot contain quotes
   $title = str_replace('"', "&quot;", $title);
   //remove newlines. Browsers don't support them anyway and they'll confuse line break converter in filter.module
   $title = str_replace("\n", " ", $title);
   $title = str_replace("\r", "", $title);
   //return '<sup class="see_reference" title="'. $title .'"><a href="#reference' . $n . '">' . $n . '</a></sup>';
   //$text = '<span><a href="#reference' . $n . '">[' . $n . ']</a> </span>';
   //$text = '<span>[' . $n . ']</span>';
   //$text .= '<span class="hovertip">'._biblio_citekey_print($title) .'</span>';

   $text = '<span hovertip="reference'. $n .'">[' . $n .']</span>';
   if (module_exists('hovertip')) {
     $text .= '<div id="reference'. $n .'" class="hovertip"><h1>Reference</h1>'._biblio_citekey_print($title) .'</div>';
   }
   return $text;

}
function biblio_taxonomy($op, $type, $array = NULL) {

  if ($op == 'delete' && $term['vid'] == variable_get('biblio_freetagging_vocab',0)) {
    switch ($type) {
      case 'term':
        break;
      case 'vocabulary':
        variable_del('biblio_keyword_freetagging');
        variable_del('biblio_freetagging_vocab');
        break;

    }

  }

}

function theme_biblio_openurl($openURL) {
	$openurl_image = variable_get('biblio_openurlimage','');

	if ($openurl_image !='')
  {
    $output .= '<div class="biblio-openurl-image"><a href="'.  $openURL . '"><img border="0" src="' . $openurl_image . '" /></a></div>';
  } else {
    $output .= '<div class="biblio-openurl-text"><a href="'.  $openURL . '">'.t('Find It Via OpenURL!').'</a></div>';

  }
	return $output;
}

function biblio_openURL($node) {
  // Copyright:          Matthias Steffens <mailto:refbase@extracts.de> and the file's
  //                     original author.
  // Original Author:    Richard Karnesky <mailto:karnesky@gmail.com>  //
  // Adapted for biblio: Ron Jerome

//  global $openURLResolver; // these variables are defined in 'ini.inc.php'
//  global $hostInstitutionAbbrevName;
  $openURLResolver = variable_get('biblio_baseopenurl','');

  $co = biblio_contextObject($node);
  $co["sid"] = "biblio:" . variable_get('site_name', 'Drupal');

  $openURL = $openURLResolver;

  if (!ereg("\?", $openURLResolver))
    $openURL .= "?";
  else
    $openURL .= "&amp;";

  $openURL .= "ctx_ver=Z39.88-2004";

  foreach ($co as $coKey => $coValue) {
    $coKey = ereg_replace("rft.", "", $coKey);
    $coKey = ereg_replace("au[0-9]*", "au", $coKey);
    $openURL .= "&amp;" . $coKey . "=" . rawurlencode($coValue);
  }

  return $openURL;
}

function biblio_coins_generate(&$node) {

  if ($node) {
      $node->biblio_coins = biblio_coins($node);
      db_query("UPDATE {biblio} SET biblio_coins = '%s' WHERE vid = %d",$node->biblio_coins,$node->vid);

  }else{
    $result = db_query("SELECT nr.*, b.*  FROM {node} AS n LEFT JOIN {node_revisions}  AS nr ON n.vid = nr.vid LEFT JOIN {biblio} AS b ON n.vid = b.vid WHERE n.type = 'biblio'  ");
    while ($node = db_fetch_object($result)) {
      $node->biblio_coins = biblio_coins($node);
      db_query("UPDATE {biblio} SET biblio_coins = '%s' WHERE vid = %d",$node->biblio_coins,$node->vid);
    }
    drupal_goto('');
  }
}

function biblio_coins($node) {
  // Copyright:          Matthias Steffens <mailto:refbase@extracts.de> and the file's
  //                     original author.
  // Original Author:    Richard Karnesky <mailto:karnesky@gmail.com>  //
  // Adapted for biblio: Ron Jerome
  // fmt_info (type)
  $fmt = "info:ofi/fmt:kev:mtx:";
  // 'dissertation' is compatible with the 1.0 spec, but not the 0.1 spec
  if ($node->biblio_type == 108)
    $fmt .= "dissertation";
  elseif ( $node->biblio_type  == 102)
    $fmt .= "journal";
  elseif ($node->biblio_type  == 100 || $node->biblio_type  == 101 )
    $fmt .= "book";
  // 'dc' (dublin core) is compatible with the 1.0 spec, but not the 0.1 spec.
  // We default to this, as it is the most generic type.
  else
    $fmt .= "dc";

  $co = biblio_contextObject($node);

  $coins = "ctx_ver=Z39.88-2004" . "&amp;rft_val_fmt=" . urlencode($fmt);

  foreach ($co as $coKey => $coValue) {
    // 'urlencode()' differs from 'rawurlencode() (i.e., RFC1738 encoding)
    // in that spaces are encoded as plus (+) signs
    $coKey = ereg_replace("au[0-9]*", "au", $coKey);
    $coins .= "&amp;" . $coKey . "=" . urlencode($coValue);
  }

  $coinsSpan = "<span class=\"Z3988\" title=\"" . $coins . "\"></span>";

  return $coinsSpan;
}

function biblio_contextObject($node) {
  // Copyright:          Matthias Steffens <mailto:refbase@extracts.de> and the file's
  //                     original author.
  // Original Author:    Richard Karnesky <mailto:karnesky@gmail.com>  //
  // Adapted for biblio: Ron Jerome
  global $base_url;
 // $openurl_base = variable_get('biblio_baseopenurl','');

  $co = array();

  // rfr_id
  $co["rfr_id"] = "info:sid/" . ereg_replace("http://", "", $base_url);

  // genre (type)
  if (isset($node->biblio_type )) {
    if ($node->biblio_type  == 102 )
      $co["rft.genre"] = "article";
    elseif ($node->biblio_type  == 101 )
      $co["rft.genre"] = "bookitem";
    elseif ($node->biblio_type  == 100 )
      $co["rft.genre"] = "book";
    elseif ($node->biblio_type  == "Journal")
      $co["rft.genre"] = "journal";
  }

  // atitle, btitle, title (title, publication)
  if (($node->biblio_type  == 102) || ($node->biblio_type  == 101)) {
    if (!empty($node->title ))
      $co["rft.atitle"] = $node->title ;
    if (!empty($node->biblio_secondary_title )) {
      $co["rft.title"] = $node->biblio_secondary_title ;
      if ($node->biblio_type  == 101)
        $co["rft.btitle"] = $node->biblio_secondary_title ;
    }
  }
  elseif (!empty($node->title ))
    $co["rft.title"] = $node->title ;
  if (($node->biblio_type  == 100) && (!empty($node->title )))
    $co["rft.btitle"] = $node->title ;

  // stitle (abbrev_journal)
  if (!empty($node->biblio_short_title ))
    $co["rft.stitle"] = $node->biblio_short_title ;

  // series (series_title)
  if (!empty($node->biblio_tertiary_title ))
    $co["rft.series"] = $node->biblio_tertiary_title ;

  // issn
  if (!empty($node->biblio_issn ))
    $co["rft.issn"] = $node->biblio_issn ;

  // isbn
  if (!empty($node->biblio_isbn ))
    $co["rft.isbn"] = $node->biblio_isbn ;

  // date (year)
  if (!empty($node->biblio_date )) {
    $co["rft.date"] = _biblio_date($node->biblio_date,'Y-m-d');
  } elseif (!empty($node->biblio_year )) {
    $co["rft.date"] = $node->biblio_year ;
  }

  // volume
  if (!empty($node->biblio_volume ))
    $co["rft.volume"] = $node->biblio_volume ;

  // issue
  if (!empty($node->biblio_issue ))
    $co["rft.issue"] = $node->biblio_issue ;

  // spage, epage, tpages (pages)
  // NOTE: lifted from modsxml.inc.php--should throw some into a new include file
  if (!empty($node->biblio_pages )) {
    if (ereg("[0-9] *- *[0-9]", $node->biblio_pages )) {
      list($pagestart, $pageend) = preg_split('/\s*[-]\s*/', $node->biblio_pages );
      if ($pagestart < $pageend) {
        $co["rft.spage"] = $pagestart;
        $co["rft.epage"] = $pageend;
      }
    }
    elseif ($node->biblio_type  == 100) {//"Book Whole") {
      $pagetotal = preg_replace('/^(\d+)\s*pp?\.?$/', "\\1", $node->biblio_pages );
      $co["rft.tpages"] = $pagetotal;
    }
    else
      $co["rft.spage"] = $node->biblio_pages ;
  }

  // aulast, aufirst, author (author)
  if (!empty($node->biblio_authors )) {
    $author_array = explode(";", $node->biblio_authors );
     $creators = _parse_author_array($author_array);

    if (!empty($creators[0]['last_name']))
      $co["rft.aulast"] = $creators[0]['last_name'];
    if (!empty($creators[0]['first_name'])) {
      $co["rft.aufirst"] = $creators[0]['first_name'];
    }elseif (!empty($creators[0]['initials'])) {
      $co["rft.aufirst"] = $creators[0]['initials'];
    }
    // TODO: cleanup and put this function in include.inc.php?
    $authorcount = count($creators);
    for ($i=1; $i < $authorcount; $i++) {
      if (!empty($creators[$i]['last_name'])) {
        $au = $creators[$i]['last_name'];
        if (!empty($creators[$i]['first_name']) ||!empty($creators[$i]['initials']))
          $au .= ", ";
      }
      if (!empty($creators[$i]['first_name'])) {
        $au .= $creators[$i]['first_name'];
      } elseif (!empty($creators[$i]['initials'])) {
        $au .=  $creators[$i]['initials'];
      }
      if (!empty($au))
        $co["rft.au".$i] = $au;
    }
  }

  // pub (publisher)
  if (!empty($node->biblio_publisher ))
    $co["rft.pub"] = $node->biblio_publisher ;

  // place
  if (!empty($node->biblio_place_published ))
    $co["rft.place"] = $node->biblio_place_published ;

  // id (doi, url)
  if (!empty($node->biblio_doi ))
    $co["rft_id"] = "info:doi/" . $node->biblio_doi ;
  elseif (!empty($node->biblio_url ))
    $co["rft_id"] = $node->biblio_url ;
  return $co;
}

function _biblio_get_user_pubs($user,$profile=''){

    switch ((isset($user->biblio_profile_uid) ) ? $user->biblio_profile_uid : variable_get('biblio_profile_uid', 'uid')){
    case 'lastname':
      $pubs = biblio_db_search('author', $user->biblio_lastname, $profile);
      break;
    case 'uid_lastname':
      $pubs = biblio_db_search('uid', $user->uid, 'author', $user->biblio_lastname, $profile);
    break;
    case 'uid':
    default:
      $pubs = biblio_db_search('uid', $user->uid, $profile);
    }
  return $pubs;

}

/**
 * Implementation of hook_token_list() for og specific tokens
 */
function biblio_token_list($type = 'all') {
  if ($type == 'node') {
    $tokens['node']['biblio_year']          = t("Biblio: Publication year");
    $tokens['node']['biblio_authors']      = t("Biblio: Authors");
    $tokens['node']['biblio_type_id']      = t("Biblio: Type ID (e.g.: 100)");
    $tokens['node']['biblio_type']      = t("Biblio: Type Name (e.g.: book)");
    return $tokens;
  }
}

/**
 * Implementation of hook_token_values() for og specific tokens
 */
function biblio_token_values($type, $object = NULL) {
  switch ($type) {
    case 'node':
      if ($object->type == "biblio") {
        $type = db_result(db_query('SELECT name FROM {biblio_types} as t WHERE t.tid = %d',$object -> biblio_type));
        #$title = db_result(db_query("SELECT title FROM {node} WHERE nid = %d", $gid));
        $values['biblio_year'] = check_plain($object -> biblio_year);
        $values['biblio_authors'] = check_plain($object -> biblio_authors);
        $values['biblio_type_id'] = check_plain($object -> biblio_type);
        $values['biblio_type'] = check_plain($type);
        return $values;
      }
      break;
  }

  // No group info found. Return defaults.
  $values['biblio_year'] = '';
  $values['biblio_authors'] = '';
  $values['biblio_type'] = '';
  return $values;
}
/*
 * Helper function for theme_biblio_format_authors() and theme_biblio_page_number()
 */
function _biblio_get_utf8_regex() {
    // Matches Unicode letters & digits:
  $alnum = "\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}"; // Unicode-aware equivalent of "[:alnum:]"

  // Matches Unicode letters:
  $alpha = "\p{Ll}\p{Lu}\p{Lt}\p{Lo}"; // Unicode-aware equivalent of "[:alpha:]"

  // Matches Unicode control codes & characters not in other categories:
  $cntrl = "\p{C}"; // Unicode-aware equivalent of "[:cntrl:]"

  // Matches Unicode dashes & hyphens:
  $dash = "\p{Pd}";

  // Matches Unicode digits:
  $digit = "\p{Nd}"; // Unicode-aware equivalent of "[:digit:]"

  // Matches Unicode printing characters (excluding space):
  $graph = "^\p{C}\t\n\f\r\p{Z}"; // Unicode-aware equivalent of "[:graph:]"

  // Matches Unicode lower case letters:
  $lower = "\p{Ll}"; // Unicode-aware equivalent of "[:lower:]"

  // Matches Unicode printing characters (including space):
  $print = "\P{C}"; // same as "^\p{C}", Unicode-aware equivalent of "[:print:]"

  // Matches Unicode punctuation (printing characters excluding letters & digits):
  $punct = "\p{P}"; // Unicode-aware equivalent of "[:punct:]"

  // Matches Unicode whitespace (separating characters with no visual representation):
  $space = "\t\n\f\r\p{Z}"; // Unicode-aware equivalent of "[:space:]"

  // Matches Unicode upper case letters:
  $upper = "\p{Lu}\p{Lt}"; // Unicode-aware equivalent of "[:upper:]"

  // Matches Unicode "word" characters:
  $word = "_\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}"; // Unicode-aware equivalent of "[:word:]" (or "[:alnum:]" plus "_")

  // Defines the PCRE pattern modifier(s) to be used in conjunction with the above variables:
  // More info: <http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php>
  $patternModifiers = "u"; // the "u" (PCRE_UTF8) pattern modifier causes PHP/PCRE to treat pattern strings as UTF-8

  return array($alnum, $alpha, $cntrl, $dash, $digit, $graph, $lower,
       $print, $punct, $space, $upper, $word, $patternModifiers);
}

function theme_biblio_format_authors($contributors, $options, $inline = false)
{
  if (empty($contributors)) return;

  $base  = variable_get('biblio_base', 'biblio');
  $author_links = variable_get('biblio_author_links', 1);
  list($alnum, $alpha, $cntrl, $dash, $digit, $graph, $lower,
       $print, $punct, $space, $upper, $word, $patternModifiers) = _biblio_get_utf8_regex();

  $auth_array = split(';', $contributors); // get a list of all authors for this record

  $authorCount = count($auth_array); // check how many authors we have to deal with
  $output = ""; // this variable will hold the final author string
  $includeStringAfterFirstAuthor = false;

  if (empty($options['numberOfAuthorsTriggeringEtAl']))  $options['numberOfAuthorsTriggeringEtAl'] = $authorCount;

  if (empty($options['includeNumberOfAuthors']))  $options['includeNumberOfAuthors'] = $authorCount;
  $i=0;
  foreach($auth_array as $rank => $author)
  {
      $singleAuthorArray = split($options['oldAuthorsInitialsDelim'], $author); // for each author, extract author name & initials to separate list items
//      if (!$familyNameFirst) // if the family name comes *after* the given name (or initials) in the source string, put array elements in reverse order:
//        $singleAuthorArray = array_reverse($singleAuthorArray); // (Note: this only works, if the array has only *two* elements, i.e., one containing the author's name and one holding the initials!)

      if (isset($singleAuthorArray[1]))
      {
        if ($options['shortenGivenNames']) // if we're supposed to abbreviate given names
        {
          // within initials, reduce all full first names (-> defined by a starting uppercase character, followed by one ore more lowercase characters)
          // to initials, i.e., only retain their first character
          $singleAuthorArray[1] = preg_replace("/([$upper])[$lower]+/$patternModifiers", "\\1", $singleAuthorArray[1]);
        }

        // within initials, remove any dots:
        $singleAuthorArray[1] = preg_replace("/([$upper])\.+/$patternModifiers", "\\1", $singleAuthorArray[1]);

        // within initials, remove any spaces *between* initials:
        $singleAuthorArray[1] = preg_replace("/(?<=[-$upper]) +(?=[-$upper])/$patternModifiers", "", $singleAuthorArray[1]);

        // within initials, add a space after a hyphen, but only if ...
        if (ereg(" $", $options['betweenInitialsDelim'])) // ... the delimiter that separates initials ends with a space
          $singleAuthorArray[1] = preg_replace("/-(?=[$upper])/$patternModifiers", "- ", $singleAuthorArray[1]);

        // then, separate initials with the specified delimiter:
        $delim = $options['betweenInitialsDelim'];
        $singleAuthorArray[1] = preg_replace("/([$upper])(?=[^$lower]+|$)/$patternModifiers", "\\1$delim", $singleAuthorArray[1]);
      }


      if ((($i == 0) AND $options['initialsBeforeAuthorFirstAuthor']) OR (($i > 0) AND $options['initialsBeforeAuthorStandard'])) // put array elements in reverse order:
        $singleAuthorArray = array_reverse($singleAuthorArray); // (Note: this only works, if the array has only *two* elements, i.e., one containing the author's name and one holding the initials!)

      // re-join author name & initials, using the specified delimiter, and copy the string to the end of an array:
      if ($i == 0) // -> first author
        $singleAuthorString = implode($options['AuthorsInitialsDelimFirstAuthor'], $singleAuthorArray);
      else // $i > 0 // -> all authors except the first one
        $singleAuthorString = implode($options['AuthorsInitialsDelimStandard'], $singleAuthorArray);

      if ($author_links) $singleAuthorString = _biblio_single_author_link($singleAuthorString, $base, $inline);

      // append this author to the final author string:
      if (($i == 0) OR ($i + 1) < $authorCount) // -> first author, or (for multiple authors) all authors except the last one
      {
        if ($i == 0) // -> first author
          $output .= $singleAuthorString;
        else // -> for multiple authors, all authors except the first or the last one
          $output .= $options['BetweenAuthorsDelimStandard'] . $singleAuthorString;

        // we'll append the string in '$customStringAfterFirstAuthors' to the number of authors given in '$includeNumberOfAuthors' if the total number of authors is greater than the number given in '$numberOfAuthorsTriggeringEtAl':
        if ((($i + 1) == $options['includeNumberOfAuthors']) AND ($authorCount > $options['numberOfAuthorsTriggeringEtAl']))
        {
          if (ereg("__NUMBER_OF_AUTHORS__", $options['customStringAfterFirstAuthors']))
            $options['customStringAfterFirstAuthors'] = preg_replace("/__NUMBER_OF_AUTHORS__/", ($authorCount - $options['includeNumberOfAuthors']), $options['customStringAfterFirstAuthors']); // resolve placeholder

          $includeStringAfterFirstAuthor = true;
          break;
        }
      }
      elseif (($authorCount > 1) AND (($i + 1) == $authorCount)) // -> last author (if multiple authors)
      {
        $output .= $options['BetweenAuthorsDelimLastAuthor'] . $singleAuthorString;
      }
    $i++;
  }

  // do some final clean up:
  if ($options['encodeHTML'])
  //$output = encodeHTML($output); // HTML encode higher ASCII characters within the newly arranged author contents

  if ($includeStringAfterFirstAuthor)
  $output .= $options['customStringAfterFirstAuthors']; // the custom string won't get HTML encoded so that it's possible to include HTML tags (such as '<i>') within the string

  $output = preg_replace("/  +/", " ", $output); // remove double spaces (which occur e.g., when both, $betweenInitialsDelim & $newAuthorsInitialsDelim..., end with a space)
  $output = preg_replace("/ +([,.;:?!()]|$)/", "\\1", $output); // remove excess spaces before [,.;:?!()] and from the end of the author string

  return $output;
}
// Format page information:
//
// NOTES: - this function (and refbase in general) assumes following rules for the original formatting of page information in '$origPageInfo':
//          - single-page items are given as a page range with identical start & end numbers (e.g. "127-127")
//          - multi-page items are given as a page range where the end number is greater than the start number (e.g. "127-132")
//          - for multi-page items where only the start page is known, a hyphen is appended to the start page (e.g. "127-")
//          - total number of pages are given with a "pp" suffix (e.g. "498 pp"), see TODO
//          - the given page info is left as is if it does not match any of the above rules (e.g. a single page number is ambiguous since it
//            could mean a single page or the total number of pages)
//        - the function attempts to deal with page locators that contain letters (e.g. "A1 - A3" or "4a-4c") but, ATM, locator parts (e.g. "A1")
//          must contain at least one digit character & must not contain any whitespace
//
// TODO:  - should we only use Unicode-aware regex expressions (i.e. always use '$space', '$digit' or '$word' instead of ' ', '\d' or '\w', etc)?
//        - recognize & process total number of pages
//        - for '$shortenPageRangeEnd=true', add support for page locators that contain letters (e.g. "A1 - A3" or "4a-4c")
function theme_biblio_page_number($origPageInfo, $pageRangeDelim = "-", $singlePagePrefix = "", $pageRangePrefix = "", $totalPagesPrefix = "", $singlePageSuffix = "", $pageRangeSuffix = "", $totalPagesSuffix = "", $shortenPageRangeEnd = false)
{
  list($alnum, $alpha, $cntrl, $dash, $digit, $graph, $lower,
       $print, $punct, $space, $upper, $word, $patternModifiers) = _biblio_get_utf8_regex();

  // Check original page info for any recognized page locators, and process them appropriately:
  if (preg_match("/\w*\d+\w* *[$dash]+ *(?:\w*\d+\w*)?/$patternModifiers", $origPageInfo)) // the original page info contains a page range (like: "127-127", "127-132", "A1 - A3", "4a-4c", or "127-" if only start page given)
  {
    // Remove any whitespace around dashes or hyphens that indicate a page range:
    $origPageInfo = preg_replace("/(\w*\d+\w*) *([$dash]+) *(\w*\d+\w*)?(?=[^\w\d]|$)/$patternModifiers", "\\1\\2\\3", $origPageInfo);

    // Split original page info into its functional parts:
    // NOTE: ATM, we simply split on any whitespace characters, then process all parts with page ranges
    //       (this will also reduce runs of whitespace to a single space)
    $partsArray = preg_split("/ +/", $origPageInfo);
    $partsCount = count($partsArray);

    for ($i=0; $i < $partsCount; $i++)
    {
      // Format parts with page ranges:
      // - single-page item:
      if (preg_match("/(\w*\d+\w*)[$dash]+\\1(?=[^\w\d]|$)/$patternModifiers", $partsArray[$i])) // this part contains a page range with identical start & end numbers (like: "127-127")
      $partsArray[$i] = preg_replace("/(\w*\d+\w*)[$dash]+\\1(?=[^\w\d]|$)/$patternModifiers", $singlePagePrefix . "\\1" . $singlePageSuffix, $partsArray[$i]);

      // - multi-page item:
      elseif (preg_match("/\w*\d+\w*[$dash]+(?:\w*\d+\w*)?(?=[^\w\d]|$)/$patternModifiers", $partsArray[$i])) // this part contains a page range (like: "127-132", or "127-" if only start page given)
      {
        // In case of '$shortenPageRangeEnd=true', we abbreviate ending page numbers so that digits aren't repeated unnecessarily:
        if ($shortenPageRangeEnd AND preg_match("/\d+[$dash]+\d+/$patternModifiers", $partsArray[$i])) // ATM, only digit-only page locators (like: "127-132") are supported
        {
          // NOTE: the logic of this 'if' clause doesn't work if the original page info contains something like "173-190; 195-195" (where, for the first page range, '$endPage' would be "190;" and not "190")
          list($startPage, $endPage) = preg_split("/[$dash]+/$patternModifiers", $partsArray[$i]);

          $countStartPage = strlen($startPage);
          $countEndPage = strlen($endPage);

          if(($countStartPage == $countEndPage) AND ($startPage < $endPage))
          {
            for ($j=0; $j < $countStartPage; $j++)
            {
              if (preg_match("/^" . substr($startPage, $j, 1) . "/", $endPage)) // if the ending page number has a digit that's identical to the starting page number (at the same digit offset)
              $endPage = substr($endPage, 1); // remove the first digit from the remaining ending page number
              else
              break;
            }
          }

          $partsArray[$i] = $pageRangePrefix . $startPage . $pageRangeDelim . $endPage . $pageRangeSuffix;
        }
        else // don't abbreviate ending page numbers:
        $partsArray[$i] = preg_replace("/(\w*\d+\w*)[$dash]+(\w*\d+\w*)?(?=[^\w\d]|$)/$patternModifiers", $pageRangePrefix . "\\1" . $pageRangeDelim . "\\2" . $pageRangeSuffix, $partsArray[$i]);
      }
    }

    $newPageInfo = join(" ", $partsArray); // merge again all parts
  }
  else
  $newPageInfo = $origPageInfo; // page info is ambiguous, so we don't mess with it

  return $newPageInfo;
}

function biblio_get_allowed_tags() {
  return array('a', 'b', 'i', 'u', 'sub', 'sup');
}